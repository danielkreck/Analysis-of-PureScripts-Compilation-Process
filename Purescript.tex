%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Simple Sectioned Essay Template
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
12pt,
ngerman,
oneside]
{scrbook} % Default font size is 12pt, it can be changed here

\usepackage[parfill]{parskip} % to avoid ident on newline

\usepackage{geometry} % Required to change the page size to A4
\geometry{a4paper,left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm} % Set the page size to be A4 as opposed to the default US Letter

\usepackage{graphicx} % Required for including pictures

\usepackage{float} % Allows putting an [H] in \begin{figure} to specify the exact location of the figure
\usepackage{wrapfig} % Allows in-line images such as the example fish picture

\usepackage{subfigure}

\usepackage{syntax} % ebnf

\linespread{1.15} % Line spacing

\graphicspath{{Pictures/}} % Specifies the directory where pictures are stored

\usepackage{paralist}

\usepackage{amssymb}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[usenames, dvipsnames]{xcolor}

\definecolor[named]{myColorMainA}{RGB}{0,26,153}
\definecolor[named]{myColorMainB}{RGB}{174,49,54}

\usepackage[pdftex]{hyperref}       
\hypersetup{
	bookmarksopen=true,
	bookmarksopenlevel=3,
	colorlinks = true,
	linkcolor  = black,
	citecolor=black
}

\usepackage{scrextend}

\usepackage[backend=bibtex,style=numeric-comp]{biblatex}
\bibliography{bib/literatur.bib}

% Nummerierungstiefen
\setcounter{tocdepth}{3} 
\setcounter{secnumdepth}{3} 		

\usepackage{csquotes}

\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage[inline]{enumitem}

\usepackage{titlesec}
\usepackage{sectsty}
\chapterfont{\color{myColorMainA}}
\sectionfont{\color{myColorMainA}}  % sets color of sections
\subsectionfont{\color{myColorMainA}} 
\subsubsectionfont{\color{myColorMainA}} 
\paragraphfont{\color{myColorMainA}} 
\subparagraphfont{\color{myColorMainA}} 
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\Huge\bfseries\color{myColorMainA}}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

\chapterfont{\color{myColorMainA}}

\usepackage{fancyhdr}
\setlength{\headheight}{15pt}

\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{ \markboth{#1}{} }
\renewcommand{\sectionmark}[1]{ \markright{#1} }

\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\textit{ \nouppercase{\leftmark}} }
\fancyhead[LO]{\textit{ \nouppercase{\rightmark}} }

\fancypagestyle{plain}{ %
	\fancyhf{} % remove everything
	\renewcommand{\headrulewidth}{0pt} % remove lines as well
	\renewcommand{\footrulewidth}{0pt}
}

%% begin lstlisting --------------------------------------------
\usepackage{caption}
\usepackage{listings}
\usepackage{textcomp} % to have single quotes like this '

% Define Colors
\definecolor{rotpink}{RGB}{168,1,99}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\definecolor{eclipseBlue}{RGB}{42,0.0,255}
\definecolor{eclipseGreen}{RGB}{63,127,95}
\definecolor{eclipsePurple}{RGB}{127,0,85}

% Defines a new code listing style
\lstdefinestyle{numbered-and-boxed}{
	frame=trbl, % draw a frame at the top, right, left and bottom of the listing
	frameround=tttt, % make the frame round at all four corners
	framesep=4pt, % quarter circle size of the round corners
	numbers=left, % show line numbers at the left
	numberstyle=\tiny\ttfamily, % style of the line numbers	
	numbersep=10pt
}

\lstdefinestyle{numbered-and-lines}{
	frame=lines, % draw a frame at the top, right, left and bottom of the listing
	numbers=left, % show line numbers at the left
	numberstyle=\tiny\ttfamily, % style of the line numbers
	numbersep=10pt
}

\lstdefinestyle{only-lines}{
	frame=lines, % draw a frame at the top, right, left and bottom of the listing
}

\lstdefinestyle{only-rect}{
	frame=trbl, % draw a frame at the top, right, left and bottom of the listing
}

% Define Language
\lstdefinelanguage{javascript}{
	% list of keywords (reserved words)
	keywords={abstract, arguments, await, boolean, break, byte, case, catch, char, class, const, continue, debugger, default, delete, do, double, else, enum, eval, export, extends, false, final, finally, float, for, function, goto, if, implements, import, in, instanceof, int, interface, let, long, native, new, null, package, private, protected, public, return, short, static, super, switch, synchronized, this, throw, throws, transient, true, try, typeof, var, void, volatile, while, with, yield},
	keywordstyle=\color{eclipsePurple},
	% list of built-in objects, properties and methods, which shouldn't be used
	deletekeywords={}, % delete single first class keywords	and use them as 2. class
	morekeywords={[2]{Array, Date, eval, function, hasOwnProperty, Infinity, isFinite, isNaN, isPrototypeOf, length, Math, NaN, name, Number, Object, prototype, String, toString, undefined, valueof}},
	keywordstyle={[2]{\color{eclipseBlue}\bfseries}},
	% list of HTML and Window objects and properties, which shouldn't be used
	morekeywords={[3]{alert, all, anchor, anchors, area, assign, blur, button, checkbox, clearInterval, clearTimeout, clientInformation, close, closed, confirm, constructor, crypto, decodeURI, decodeURIComponent, defaultStatus, document, element, elements, embed, embeds, encodeURI, encodeURIComponent, escape, event, fileUpload, focus, form, forms, frame, innerHeight, innerWidth, layer, layers, link, location, mimeTypes, navigate, navigator, frames, frameRate, hidden, history, image, images, offscreenBuffering, open, opener, option, outerHeight, outerWidth, packages, pageXOffset, pageYOffset, parent, parseFloat, parseInt, password, pkcs11, plugin, prompt, propertyIsEnum, radio, reset, screenX, screenY, scroll, secure, select, self, setInterval, setTimeout, status, submit, taint, text, textarea, top, unescape, untaint, window}},
	keywordstyle={[3]{\color{eclipseBlue}\bfseries}},
	% list of HTML Event handels, which shouldn't be used as identifiers
	morekeywords={[4]{onblur, onclick, onerror, onfocus, onkeydown, onkeypress, onkeyup, onmouseover, onload, onmouseup, onmousedown, onsubmit}},
	keywordstyle={[4]{\color{eclipseBlue}\bfseries}},
	keywordstyle={[3]{\color{eclipseBlue}\bfseries}},
	% node.js built-in's, which shouldn't be used as identifiers
	morekeywords={[5]{require, module, exports}},
	keywordstyle={[5]{\color{eclipseBlue}\bfseries}},
	identifierstyle=\color{black},
	sensitive=true, % keywords are case-sensitive in JavaScript
	comment=[l]{//}, % l is for line comment
	morecomment=[s]{/*}{*/}, % s is for start and end delimiter
	commentstyle=\color{darkgray},
	stringstyle=\color{eclipseGreen},
	morestring=[m]', % defines that strings are enclosed in single quotes
	morestring=[m]", % defines that strings are enclosed in double quotes
	alsoletter=?,
	alsodigit=-
}

\lstdefinelanguage{purescript}{
	% list of keywords (reserved words)
	keywords={data, type, newtype, foreign, import, infixl, infixr, infix, class, instance, module, case, of, if, then, else, do, let, true, false, in, where, forall},
	keywordstyle=\color{eclipsePurple},
	% list of reserved operators, which shouldn't be used
	deletekeywords={}, % delete single first class keywords	and use them as 2. class
	morekeywords={[2]{=>, ->, =, ., \\\\}},
	keywordstyle={[2]{\color{black}\bfseries}},
	% built-in functions
	morekeywords={[3]{lookup}},
	keywordstyle={[3]{\color{eclipseBlue}\bfseries}},
	% built-in data types
	morekeywords={[4]{String, Map}},
	keywordstyle={[4]{\color{eclipseBlue}\bfseries}},
	identifierstyle=\color{black},
	sensitive=true, % keywords are case-sensitive in JavaScript
	comment=[l]{--}, % l is for line comment
	morecomment=[s]{\{-}{-\}}, % s is for start and end delimiter
	commentstyle=\color{darkgray},
	stringstyle=\color{eclipseGreen},
	morestring=[m]', % defines that strings are enclosed in single quotes
	morestring=[m]", % defines that strings are enclosed in double quotes
	alsoletter={=>, ->, =, ., \\\\},
	alsodigit=-
}

% Set Language, basic common setup for all javascript listings
\lstset{
	language={javascript},
	basicstyle=\small\ttfamily, % Global Code Style
	captionpos=b, % Position of the Caption (t for top, b for bottom)
	extendedchars=true, % Allows 256 instead of 128 ASCII characters
	tabsize=2, % number of spaces indented when discovering a tab 
	showtabs=false,
	columns=fixed, % make all characters equal width
	keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
	showstringspaces=false, % lets spaces in strings appear as real spaces
	breaklines=true, % wrap lines if they don't fit
	upquote=true % single quotes should look like this '
}
%% end lstlisting ----------------------------------------------


\begin{document}
	
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begin{titlepage}
	
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here
	
	\center % Center everything on the page
	
	\textsc{\LARGE Technische Hochschule Mittelhessen}\\[1.5cm] % Name of your university/college
	\textsc{\Large Kernel-Architekturen in Programmiersprachen}\\[0.5cm] % Major heading such as course name
	\textsc{\large Projektarbeit}\\[0.5cm] % Minor heading such as course title
	
	\HRule \\[0.7cm]
	{ \huge \bfseries Eine Analyse der grundlegenden Ãœbersetzungsmechanik der Sprache PureScript}\\[0.4cm] % Title of your document
	\HRule \\[1.5cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Autor:}\\
			Daniel \textsc{Kreck} % Your name \\
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright} \large
			\emph{Dozent:} \\
			Prof. Dr. D. \textsc{Herzberg} % Supervisor's Name
		\end{flushright}
	\end{minipage}\\[4cm]
	
	{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise
	
	%\includegraphics{Logo}\\[1cm] % Include a department/university logo - this will require the graphicx package
	
	\vfill % Fill the rest of the page with whitespace
	
\end{titlepage}


%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

\tableofcontents % Include a table of contents

\newpage % Begins the essay on a new page instead of on the same page as the table of contents 


%----------------------------------------------------------------------------------------
%	CONTENT
%----------------------------------------------------------------------------------------

\chapter{Zielsetzung und Vorgehen}
In diesem Kapitel wird die Projektaufgabe des Moduls Kernel-Architekturen in Programmiersprachen, im Fachbereich MNI der Technischen Hochschule Mittelhessen, beschrieben.

\section{Kontext}
Im Rahmen des Moduls Kernel-Architekturen in Programmiersprachen beschÃ¤ftigen wir uns mit Sprachen dieser Art. Dies sind Sprachen, welche aus einem kleinen Sprachkern aufgebaut und meist funktionaler Natur sind.

Der Dozent Prof. Dr. Dominikus Herzberg entwickelte zu Lehrzwecken die Kernel-basierte konkatenative Sprache Consize in der Programmiersprache Clojure. Diese galt es zum Einstieg in das Modul in einer Sprache der eigenen Wahl zu reimplementieren. PrÃ¼fungsleistung kann es sein, Consize um weitere SprachfunktionalitÃ¤ten zu erweitern oder eine Analyse einer anderen Kernel-basierten Programmiersprache vorzunehmen. 

\section{Problem}
Als individuelle Projektaufgabe soll sich mit einer Kernel-basierten Sprache beschÃ¤ftigt und ihr Ãœbersetzungsmechanismus beschrieben werden. Das dient dem Zweck zu ergrÃ¼nden wie dieser aussieht und aufgebaut ist, welche Sprachkonstrukte zur Abbildung genutzt werden und damit auch zu erforschen, wie eine sich in der Praxis befindliche Kernel-basierte Sprache strukturiert ist und im Kern funktioniert. Es geht also nicht um weniger, als zu erforschen, wie gut man sich einer fremden Sprache unter einem potentiell fremden Paradigma nÃ¤hern kann, wenn man den Zielcode analysiert, der auf ein bereits bekanntes Paradigma aufsetzt.

\section{Aufgabe}
Dem Problem wird mit der Programmiersprache Purescript, welche nach Javascript kompiliert, begegnet. Ziel ist es Muster in der Ãœbersetzung von PureScript nach JavaScript zu erkennen sowie zu beschreiben und sich dadurch der Sprache PureScript zu nÃ¤hern.

Der Beschreibungsprozess ist wie folgt aufgebaut. Die aufgegriffenen Spachelemente von Purescript werden erklÃ¤rt und damit wird kein Wissen in der Sprache selbst vorausgesetzt, um sie zu verstehen. Im Anschluss wird die Ãœbersetzung nach Javascript aufgezeigt und diese Abbildung beschrieben. Das hat zur Folge, dass die Kapitel thematisch aufeinander aufbauen mÃ¼ssen. Als erstes steht bspw. das Modulkonzept von PureScript, gefolgt von Funktionen, ohne Typdeklarationen einzufÃ¼hren. Diese werden erst genutzt, wenn Typen im nÃ¤chsten Kapitel eingefÃ¼hrt wurden. Allgemeine Begriffe oder Definitionen der Informatik, insbesondere der Softwareentwicklung, werden allerdings vorausgesetzt.

Um im Vorgehen systematisch zu sein, wird sich anhand der Gliederung des Buches \glqq PureScript by Example\grqq{} von Phil Freeman orientiert. Die grÃ¶ÃŸten und wichtigsten ThemenblÃ¶cke bilden in dieser Ausarbeitung die Kapitel. Kleinere oder von ihrer Abbildung her uninteressantere Themenbereiche flieÃŸen entweder innerhalb eines Kapitels am Rande ein oder werden nicht betrachtet. Ein Beispiel fÃ¼r einen wichtigen Themenblock, der ein Kapitel aufspannt, sind Typen, untergliedert in einfache Typen, Algebraische Typen und Typklassen. Ein Beispiel fÃ¼r einen Themenbereich, der nur am Rande einflieÃŸt, wÃ¤re bspw. Pattern Matching.


\chapter{Module und Bezeichner}
Ein PureScript Programm ist eine Sammlung von Modulen. Module definieren NamensrÃ¤ume und sind wiederum eine Sammlung von Funktionen, Typen sowie Typklassen fÃ¼r einen bestimmten Zweck. In PureScript werden Module durch das \lstinline[language=purescript, columns=fixed]{module} SchlÃ¼sselwort beschrieben. Ein Modul kann Ã¼ber \lstinline[language=purescript, columns=fixed]{import} weitere FunktionalitÃ¤t aus anderen Modulen importieren und nutzen sowie Ã¼ber eine Exportliste entscheiden, welche der eigenen FunktionalitÃ¤t fÃ¼r externe Module sichtbar ist \cite{PSModules18}. Durch Listing \ref{BasicModulePS} wird dieses Konzept am einfachen Beispiel der IdentitÃ¤tsfunktion demonstriert. Im Gegensatz zu Haskell wird die Prelude in PureScript wie jedes andere Modul behandelt und muss damit explizit importiert werden\footnote{In diesem Fall ist der Import nicht erforderlich, da keine FunktionalitÃ¤ten aus der Prelude genutzt werden - ihr Import dient einzig zur Demonstration des Importmechanismus von Modulen}. Sie definiert elementare Operationen, wie z.B. bereits die Addition oder Multiplikation, sofern es sich um die standardmÃ¤ÃŸige Prelude handelt, da dieses Konzept es ebenso ermÃ¶glicht eine eigene Prelude zu definieren \cite{PSDifferences-from-Haskell18}.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Einfache Moduldefinition mit Imports und Exports in PureScript, label=BasicModulePS]
module Main (exportedIdentity) where

import Prelude

exportedIdentity x = x
notExportedIdentity x = x 
\end{lstlisting}

Das Modul mit der Bezeichnung \emph{Main} beinhaltet zwei Funktionen - zweimal die Definition der IdentitÃ¤tsfunktion. Die eine wird durch die Angabe zwischen Modulbezeichnung und \lstinline[language=purescript, columns=fixed]{where} SchlÃ¼sselwort, welches einen neuen Codeblock einfÃ¼hrt, exportiert. Die andere bleibt lediglich innerhalb des Moduls zugreifbar.
Wird keine Exportliste angegeben, werden implizit alle Bestandteile des Moduls exportiert.

In Listing \ref{BasicModuleJS} ist die Ãœbersetzung des vorangegangenen PureScript-Beispiels abgebildet. Man erkennt durch die Direktive in der ersten Zeile, dass JavaScript im Strict Mode ausgefÃ¼hrt werden soll. In diesem ist es bspw. nicht mÃ¶glich undeklarierte Variablen zu nutzen \cite{w3schoolsJSStrictMode18}. FÃ¼r den Import und Export von Modulen wird auf die Node.js Funktionen \lstinline[language=javascript, columns=fixed]{require} und  \lstinline[language=javascript, columns=fixed]{exports} zurÃ¼ckgegriffen. Dies bedeutet, dass Module JavaScript Objekte werden, welche die zu exportierenden Member des Moduls kapseln \cite{NodeJSModules18}.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Ãœbersetzung der einfachen Moduldefinition nach JavaScript, label=BasicModuleJS]
"use strict";
var Prelude = require("../Prelude");

var notExportedIdentity = function (x) { return x; };
var exportedIdentity = function (x) { return x; };

module.exports = {
	exportedIdentity: exportedIdentity
};
\end{lstlisting}

 Nach dem Ãœbersetzungsvorgang liegt im jeweiligen Ausgabeverzeichnis ein Verzeichnis, welches den Modulnamen, hier \emph{Main}, trÃ¤gt und in diesem mindestens zwei weitere Dateien - eine JavaScript-Datei (index.js) mit dem entsprechenden Zielcode und eine Datei im JSON-Format (externs.json), die Metainformationen enthÃ¤lt. Das Ã¼bersetzte Prelude-Module befindet sich mit gleicher Struktur  ebenfalls im Ausgabeverzeichnis, was dessen Import in Listing \ref{BasicModuleJS} durch die Pfadangabe bereits andeutet.

PureScript Funktionen werden zu JavaScript Funktionen Ã¼bersetzt, wobei deren ursprÃ¼ngliche Bezeichnungen, sofern keine Namenskonflikte entstehen, versucht werden beizubehalten \cite[][S. 10]{Freeman17}. Nutzt man zum Beispiel reservierte Bezeichner in JavaScript als Bezeichner in PureScript werden sie durch das Voranstellen zweier Dollar Symbole maskiert. Wird eine Bezeichnung in PureScript gewÃ¤hlt, welcher in JavaScript unzulÃ¤ssig ist, wird sie durch ein einfaches Dollar Symbol maskiert. In Listing \ref{NameGenerationPS} und \ref{NameGenerationJS} sind diese beiden FÃ¤lle exemplarisch aufgefÃ¼hrt \cite[][S. 144]{Freeman17}.

\noindent\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=purescript, style=only-rect, caption= Name Generation PS, label=NameGenerationPS]
	null = []
	example' = 100
	\end{lstlisting}
\end{minipage}% 
% 
\hfill% 
\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=javascript, style=only-rect, caption= Name Generation JS, label=NameGenerationJS] 
	var $$null = [];
	var example$prime = 100;
	\end{lstlisting}
\end{minipage}
\hfill% 


\chapter{Kommentare}
In PureScript gibt es zwei Arten von Kommentaren - Zeilen- sowie Blockkommentare. Der PureScript Compiler ignoriert diese nicht wie Ã¼blich wÃ¤hrend der Ãœbersetzung, sondern wandelt sie in ihr JavaScript-Pendant um und bettet sie in den Zielcode ein. Leerzeichen werden ebenfalls eins zu eins Ã¼bernommen, wie in Listing \ref{CommentsPS} und \ref{CommentsJS} dargestellt.
\noindent\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=purescript, style=only-rect, caption= Kommentare PS, label=CommentsPS]
	-- single line comment
	
	{- multiline comment which can
		continue for many lines
	-}
	\end{lstlisting}
\end{minipage}% 
% 
\hfill% 
\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=javascript, style=only-rect, caption= Kommentare JS, label=CommentsJS] 
	// single line comment
	
	/**
	*  multiline comment which can
	*    continue for many lines
	*/
	\end{lstlisting}
\end{minipage}
\hfill% 
Kommentare, die mit einem Pipe-Zeichen beginnen, werden als Dokumentation gesehen und erscheinen in Tools wie Pursuit\footnote{Pursuit ist ein Webdienst, der es einem erlaubt die API Dokumentation von PurseScript nach Paketen, Modulen, Funktionen usw.  zu durchsuchen - \href{https://pursuit.purescript.org/}{https://pursuit.purescript.org/}}. Im Gegensatz zu Haskell muss bei mehreren Zeilenkommentaren untereinander, jede Zeile, die als Dokumentation dienen soll, mit dem Pipe-Zeichen beginnen \cite{PSSyntax18}.


\chapter{Funktionsdefinition und -applikation}
\label{functionDefAndApp}
Funktionen in PureScript werden auf JavaScript Funktionen abgebildet und kÃ¶nnen auf oberster Ebene eines Moduls definiert werden, indem der Funktionsbezeichner gefolgt von beliebig vielen Funktionsargumenten vor dem Gleichheitszeichen und der FunktionskÃ¶rper hinter diesem geschrieben werden \cite[][S. 17]{Freeman17}. Als Beispiel diene hierzu die Funktion \emph{addTwo} in Listing \ref{FunctionPS}. Alle weiteren AusfÃ¼hrungen beziehen sich ebenfalls auf dieses und Listing \ref{FunctionJS} (gekÃ¼rzt um Strict Mode Direktive und Exports), welches dessen Ãœbersetzung nach JavaScript aufzeigen soll. 

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Funktionen in PureScript, label=FunctionPS]
module Main where

import Prelude ((+))

addTwo a b = a + b
constant = addTwo 2 3
\end{lstlisting}

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Funktionen in JavaScript, label=FunctionJS]
var Data_Semiring = require("../Data.Semiring");
var Prelude = require("../Prelude");

var addTwo = function (dictSemiring) {
	return function (a) {
		return function (b) {
			return Data_Semiring.add(dictSemiring)(a)(b);
		};
	};
};

var constant = addTwo(Data_Semiring.semiringInt)(2)(3);
\end{lstlisting}

Im Vergleich zu ihrem GegenstÃ¼ck in JavaScript nehmen Funktionen in PureScript immer nur ein Argument an - wie auch in Haskell \cites[][]{PSTypes18}[][Kap. Higher order functions, Abschn. Curried functions]{Haskell11}. Unsere Funktion \emph{addTwo}, welche offensichtlich zwei Argumente anzunehmen scheint, ist ein Beispiel fÃ¼r eine \textbf{Curried Function}\footnote{\href{https://de.wikipedia.org/wiki/Currying}{https://de.wikipedia.org/wiki/Currying}}. Aus diesem Aspekt erschlieÃŸt sich die Ãœbersetzung nach Javascript in den Zeilen fÃ¼nf bis neun und auch die schrittweise Funktionsapplikation in der letzten Zeile. 

Bleibt zu erlÃ¤utern wie Operationen wie die Addition, und wie die Funktionsapplikation in JavaScript umgesetzt werden. Ersteres wird auf den Abschnitt  \glqq \ref{typesAndTypeClasses} \nameref{typesAndTypeClasses}\grqq{} vertagt, da zuvor Typen und Typklassen eingefÃ¼hrt werden mÃ¼ssen. FÃ¼r jetzt reicht es aus den Zielcode rund um das Modul \emph{Data.Semiring}\footnote{ist an die Algebraische Struktur des Halbringes aus der Mathematik angelehnt - \href{https://de.wikipedia.org/wiki/Halbring_(Algebraische_Struktur)}{https://de.wikipedia.org/wiki/Halbring_(Algebraische_Struktur)}} aus dem Blickwinkel zu betrachten, dass die Addition bekannterweise eine typabhÃ¤ngige Operation darstellt, was zu dem zusÃ¤tzlichen Zielcode fÃ¼hrt, der die bereits erlÃ¤uterte FunktionalitÃ¤t umschlieÃŸt. In diesem Fall bezieht er sich auf den Integer-Typ, weil in der Funktionsapplikation in Zeile 6 bzw. 12 des jeweiligen Listings Ganzzahlen genutzt werden und der Compiler durch Typinferenz die passende typabhÃ¤ngige Ãœbersetzung vorgenommen hat - \emph{\mbox{Data_Semiring.semiringInt}} als typgebundene Berechnungsfunktion in der Funktion \emph{addTwo}.

Die Funktionsapplikation wird in PureScript durch das einfache hintereinanderschreiben (auch Juxtaposition genannt) des Funktionsbezeichners und den Argumenten durchgefÃ¼hrt \cite{PSSyntax18}. Einfache Leerzeichen dienen als Trennsymbol, wie in Zeile sechs des Listings \ref{FunctionPS} zu sehen. Funktionsapplikationen in PureScript werden als Funktionsapplikationen in JavaScript aufgelÃ¶st \cite[][S. 10]{Freeman17}. Die Auswertung des Funktionsaufrufs von \emph{addTwo} fÃ¼hrt zu einem Wert. Da PureScript eine rein funktionale Programmiersprache ist und nur Funktionen kennt, handelt sich bei \emph{constant} nicht um eine Variable an die der Wert gebunden wird, sondern um eine konstante Funktion.

\section{Sonderfall Main-Modul und Main-Funktion}
PureScript erwartet als Programmeinstiegspunkt ein Modul mit dem Namen \emph{Main}, in dem eine Funktion namens \emph{main} definiert sein muss. Die reine Ãœbersetzung (\emph{pulp build}) tangiert nachfolgende AusfÃ¼hrungen nicht. Sie beziehen sich lediglich auf die AusfÃ¼hrung des Zielcodes (\emph{pulp run}).

Einer Main-Funktion in einem anderweitig benannten Modul wird keine besondere Bedeutung zu Teil. Bei der AusfÃ¼hrung wird ein Main-Modul ohne Main-Funktion beanstandet, ebenso wie dessen komplettes Fehlen. ZusÃ¤tzlich muss die Main-Funktion entweder vom Typ \emph{Effect.Effect} oder \emph{Control.Monad.Eff.Eff} sein. Alle genannten Fehler kÃ¶nnen Ã¼ber Schalter ausgeschaltet bzw. ignoriert werden. 

Ein korrektes Main-Modul wird standardmÃ¤ÃŸig zu einer Datei mit der Bezeichnung \emph{output.js}, die sich auf der gleichen Ebene wie das Ausgabeverzeichnis, welche die Ã¼bersetzten Module enthÃ¤lt, Ã¼bersetzt. In dieser wird die Main-Funktion in der letzten Zeile gestartet, nachdem alle sonstigen Module definiert worden sind. Sie ist Ã¼bersetzt als einfacher Funktionsaufruf ohne Argumente \cite[][S. 10]{Freeman17}.

\section{Lessons Learned}
\begin{itemize}
	\item Funktionen in PureScript sind Funktionen in JavaScript
	\item Durch den Einsatz von Currying nehmen alle Funktionen (syntaktischen Zucker auÃŸen vor gelassen) lediglich ein Argument entgegen - fÃ¼r partielle Anwendung ist daher keine spezielle Syntax notwendig
	\item Die Funktionsanwendung geschieht Ã¼ber die Juxtaposition von Funktion und ihren Argumenten - Klammern dienen nur der PrÃ¤zedenzsteuerung
\end{itemize}


\chapter{Typen und Typklassen}
\label{typesAndTypeClasses}
In diesem Kapitel werden wesentliche Bestandteile des Typsystems von PureScript vorgestellt und demonstriert, wie diese zur Laufzeit in JavaScript reprÃ¤sentiert werden. Alle Typinformationen sind zur Laufzeit nicht mehr vorhanden. Das Typsystem garantiert allerdings, dass der Typ eines Ausdrucks mit seiner ReprÃ¤sentation zur Laufzeit kompatibel ist, sodass ein vom Compiler akzeptiertes Programm zur Laufzeit nicht aufgrund eines Typfehlers abstÃ¼rzt \cite[][S. 144, 148]{Freeman17}.

\section{Einfache Datentypen}
In PureScript sind drei Datentypen enthalten, die direkt auf JavaScript Typen abgebildet werden. Sie werden im Modul \emph{Prim} definiert, welches implizit von jedem anderen Modul importiert wird. Es handelt sich um folgende Typen, inkl. Angabe eines Literals als Beispiel  \cite[][S. 16]{Freeman17}: 
\begin{enumerate}
	\item Number - \lstinline[language=purescript, columns=fixed]{1.0}
	\item String - \lstinline[language=purescript, columns=fixed]{"Ich bin eine Zeichenkette"}
	\item Boolean - \lstinline[language=purescript, columns=fixed]{true}
\end{enumerate}

DarÃ¼ber hinaus sind in PureScript weitere Typen fest eingebaut, wie: 
\begin{itemize}
	\item Int - \lstinline[language=purescript, columns=fixed]{1}
	\item Char - \lstinline[language=purescript, columns=fixed]{'a'}
	\item Array - \lstinline[language=purescript, columns=fixed]{[1, 2, 3]}
	\item Record -  
	\begin{lstlisting}[language=purescript]
		{ name: "Phil", interests: ["PureScript", "JavaScript"] }
	\end{lstlisting}
	\vspace{-1.8em}
	\item Function (benannt) - \lstinline[language=purescript, columns=fixed]{add a b = a + b}
	\item Function (anonym) - \lstinline[language=purescript, columns=fixed]{\a b -> a + b}
\end{itemize}
PureScript's Datentypen \emph{Int} und \emph{Char} werden in JavaScript letztlich wieder als \emph{Number} und \emph{String} reprÃ¤sentiert. Arrays in PureScript sind Arrays in JavaScript, allerdings mit der EinschrÃ¤nkung, dass alle Elemente vom gleichen Typ sein mÃ¼ssen (homogen). Records werden in PureScript in JavaScript's Objekt-Literal-Schreibweise angegeben und sind in JavaScript vom Typ \emph{object} und damit heterogener Natur.
PureScript Funktionen, ob benannt oder anonym, sind vom JavaScript Datentyp \emph{function} \cite[][S. 16--18, 145]{Freeman17}.

In PureScript gibt es keine ReprÃ¤sentation von JavaScript's \lstinline[language=javascript, columns=fixed]{null} oder \lstinline[language=javascript, columns=fixed]{undefined} Werten\footnote{sind in JavaScript gleich vom Wert, aber unterschiedlich im Datentyp -  \emph{null} ist vom Datentyp \emph{object} und \emph{undefined} von \emph{undefined}  \cite{w3schoolsJSDatatypes18}}. Das bedeutet, dass PureScript AusdrÃ¼cke, ob nun vom Datentyp \emph{Int}, \emph{String}, \emph{Array}, \emph{Record} usw., zur Laufzeit immer zu einer \textbf{Nicht-Null} ReprÃ¤sentation in JavaScript evaluiert werden \cite[][S. 145]{Freeman17}.

\section{Algebraische Datentypen}
\label{sec:ADT}
Algebraische Datentypen (kurz: ADT) sind ein Bestandteil des Typsystems von PureScript und eng verwandt mit Pattern Matching, da jeder Wertkonstruktor mit seinen Argumenten als Pattern genutzt werden kann. Sie sind ein Weg einen neuen Datentyp zu deklarieren, der aus anderen Typen zusammengesetzt ist. In PureScript werden sie mit dem SchlÃ¼sselwort \lstinline[language=purescript, columns=fixed]{data} eingefÃ¼hrt, gefolgt von einer Bezeichnung (Typkonstruktor) fÃ¼r den ADT. Nach dem Gleichheitszeichen folgen die Wertkonstruktoren. In Listing \ref{ADTPS} sind drei Sorten von Algebraischen Datentypen dargestellt \cite[][S. 57--59]{Freeman17}.

 \begin{wrapfigure}[8]{r}{.57\textwidth}
	\begin{lstlisting}[aboveskip=-1em, language=purescript, caption=Beispiel ADT, label=ADTPS]
	data Person = Person String Int
	
	data Maybe a = Nothing | Just a
	
	data List a = Nil | Cons a (List a)
	\end{lstlisting}
\end{wrapfigure}

Der erste Typ mit dem Namen \emph{Person} hat genau einen Wertkonstruktor mit dem Namen \emph{Person}, der zwei Argumente mit den Typen \emph{String} fÃ¼r den Namen einer Person und \emph{Int} fÃ¼r deren Alter hat. In diesem Fall ist es Ã¼blich, dass der Typ- und Wertkonstruktor gleich benannt sind. \emph{Maybe} ist ein Beispiel fÃ¼r einen ADT, dessen Typkonstruktor (\emph{Maybe}) einen Typparameter\footnote{das hat zur Folge, dass im Gegensatz zu bspw. Person, wo ein Wert vom Typ Person wÃ¤re, ein Wert nicht direkt vom Typ Maybe sein kann, sondern Im Fall von \emph{Nothing} von \lstinline[language=purescript, columns=fixed]{Maybe a}  und bei \emph{Just} von \lstinline[language=purescript, columns=fixed]{a -> Maybe a} } hat (\emph{a}) und der Alternativen aufspannt, also mehrere Wertkonstruktoren besitzt. Das Pipe-Symbol kann als Oder gelesen werden und trennt die Wertkonstruktoren. FÃ¼r \emph{Maybe} heiÃŸt dies, dass ein Wert vom Typ \emph{Maybe} entweder nichts ist (\emph{Nothing}) oder ein Etwas (\emph{Just}) von dem Typen \emph{a}. \emph{List} ist wie \emph{Maybe} ein ADT aus der PureScript Prelude und sagt aus, dass eine Liste entweder leer ist oder einen Kopf und einen Rest hat, der wieder eine Liste ist. Damit ist \emph{List} ein Beispiel fÃ¼r einen ADT, welcher Ã¼ber sich selbst rekursiv definiert ist \cite[][S. 57--58]{Freeman17}.

\subsection{Umsetzung von Algebraischen Datentypen  in JavaScript}
In diesem Unterabschnitt wird der ADT \emph{List} aus Listing \ref{ADTPS} zur ErlÃ¤uterung des Ãœbersetzungsmusters von Algebraischen Datentypen nach JavaScript exemplarisch genutzt. \emph{Person} und \emph{Maybe} folgen dem gleichen Muster, weshalb auf deren Ãœbersetzung in Listing \ref{ADTJS} verzichtet wird.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Ãœbersetzung nach JavaScript von ADT's am Beispiel von \emph{List}, label=ADTJS]
var Nil = (function () {
	function Nil() {

	};
	Nil.value = new Nil();
	return Nil;
})();

var Cons = (function () {
	function Cons(value0, value1) {
		this.value0 = value0;
		this.value1 = value1;
	};
	Cons.create = function (value0) {
		return function (value1) {
			return new Cons(value0, value1);
		};
	};
	return Cons;
})();
\end{lstlisting}

In Listing \ref{ADTJS} ist zu sehen, dass fÃ¼r jeden Wertkonstruktor eines ADT ein neuer JavaScript Objekttyp (Klasse) angelegt wird. Der Compiler erzeugt fÃ¼r Wertkonstruktoren mit Argumenten in JavaScript Objekt-Konstruktoren mit der entsprechenden Anzahl Argumente. Bei \emph{Cons} ist das erste Argument der Kopf und das zweite der Rest. Der Compiler erzeugt fÃ¼r die Objektinstantiierung Hilfsfunktionen, welche eingesetzt werden kÃ¶nnen, anstatt den  \emph{new}-Operator explizit nutzen zu mÃ¼ssen. Bei Konstruktoren mit keinen Argumenten, wie bei \emph{Nil}, wird ein Attribut \emph{value} angeboten, um eine wiederholte Neuinstantiierung zu vermeiden. Bei Konstruktoren mit mindestens einem Argument, wie bei \emph{Cons}, wird eine Funktion \emph{create} bereitgestellt, welches die Argumente mit Currying annimmt und den entsprechenden Konstruktor aufruft \cite[][S. 145--146]{Freeman17}.

\subsection{Wenn der Programmierer eine optimierte Ãœbersetzung explizit veranlassen kann}
In PureScript gibt es einen Sonderfall von Algebraischen Datentypen, die mit dem SchlÃ¼sselwort \lstinline[language=purescript, columns=fixed]{newtype} eingefÃ¼hrt werden. Newtypes dÃ¼rfen nur exakt einen Wertkonstruktor mit exakt einem Argument definieren. Wie der Name schon aussagt, hat das den Zweck einen neuen Namen fÃ¼r einen bestehenden Datentyp zu vergeben, ohne die LaufzeitreprÃ¤sentation des unterliegenden Datentyps zu Ã¤ndern \cite[][S. 60]{Freeman17}.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Beispiel Newtypes, label=NewTypePS]
newtype Euro = Euro Number
newtype Dollar = Dollar Number

fEuro :: Euro -> Euro
fEuro euro = euro

fDollar :: Dollar -> Dollar
fDollar dollar = dollar
\end{lstlisting}

Im Gegensatz zu reinen Typaliasen, die mit dem SchlÃ¼sselwort \lstinline[language=purescript, columns=fixed]{type} definiert werden, garantieren Newtypes dadurch, dass sie eine besondere Form von ADT's sind, Typsicherheit. In Listing \ref{NewTypePS} sind zwei NewType's definiert - Euro und Dollar. Es ist bspw. nicht mÃ¶glich einen Wert vom Typ \emph{Dollar} in die Funktion \emph{fEuro} zu Ã¼bergeben, da Euro und Dollar inkompatible Typen sind \cite[][S. 60]{Freeman17}.

Listing \ref{ADTOPTJS} veranschaulicht den Unterschied bzgl. der Ãœbersetzung nach JavaScript, wenn man \emph{Euro} als gewÃ¶hnlichen Algebraischen Datentyp oder Newtype definiert.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Ãœbersetzung nach JavaScript von Newtypes, label=ADTOPTJS]
// as newtype
var Euro = function (x1) {
	return x1;
};

// as common ADT
var Euro = (function () {
	function Euro(value0) {
		this.value0 = value0;
	};
	Euro.create = function (value0) {
		return new Euro(value0);
	};
	return Euro;
})();
\end{lstlisting}

Newtypes haben zur Laufzeit wie ADT's eine ReprÃ¤sentation, die durch den Newtype Charakter im Vergleich zu ADT's allerdings Overhead vermeidet. Dadurch eignen sich Newtypes beim Design von Bibliotheken. Ihr Typ zur Laufzeit entspricht dem ihres Arguments \cite[][S. 146--147]{Freeman17}.

\section{Typklassen}
\label{lbl:Typeclasses}

Typen kÃ¶nnen Typklassen zugeordnet werden. Ist das der Fall, definiert die Typklasse fÃ¼r ihre Typen ein bestimmtes Verhalten. Das am nÃ¤hesten zutreffende Pendant zu Typklassen in der OOP-Welt sind Interfaces \cite[Kap. Types and Typeclasses, Abschn. Typeclasses 101]{Haskell11}. 

\begin{wrapfigure}[10]{r}{.52\textwidth}
	\begin{lstlisting}[aboveskip=-1em, language=purescript, caption=Beispiel Typklassen, label=TypeClassesPS]
class Eq a where
	eq :: a -> a -> Boolean
	
data Ordering = LT | GT | EQ
	
class Eq a <= Ord a where
	compare :: a -> a -> Ordering
	\end{lstlisting}
\end{wrapfigure}

Beispielsweise gibt es in der Prelude eine Typklasse \emph{Ord}, welche fÃ¼r all ihre untergeordneten Typen aussagt, dass sie einerseits vergleichbar sind und andererseits wie der Vergleich im konkreten Fall auszusehen hat \cite[][S. 65]{Freeman17}. In Java bspw. entsprÃ¤che dies in etwa dem Interface \emph{Comparable}. Listing \ref{TypeClassesPS} zeigt die Definition der Typklasse \emph{Ord}, die eine Funktion \emph{compare} deklariert, um zwei Werte bei Typen, welche eine totale Ordnung unterstÃ¼tzen, zu vergleichen.  Von \emph{compare} wird ein Wert vom Typ \emph{Ordering}\footnote{bei \emph{Ordering} handelt es sich um einen Algebraischen Datentyp} zurÃ¼ckgegeben, der drei Wertkonstruktoren als Alternative spezifiziert - \emph{LT}, wenn das erste Argument kleiner als das zweite ist, \emph{GT}, wenn es grÃ¶ÃŸer ist und \emph{EQ} wenn beide gleich sind \cite[][S. 66]{Freeman17}. Die Typklasse  \emph{Ord} ist durch die Typvariable \emph{a} parametrisiert. Typvariablen stehen als Platzhalter fÃ¼r einen beliebigen konkreten Typen. Man erkennt sie daran, dass sie mit keinem GroÃŸbuchstaben anfangen, wie es fÃ¼r Typen vorgeschrieben ist, aber an der Stelle von Typen stehen. In Sprachen wie Java kommen Generics Typvariablen am nÃ¤chsten. Funktionen, die mit Typvariablen definiert sind, werden als polymorphe Funktion bezeichnet, das Konzept im Allgemeinen als Parametrisierte Polymorphie \cite[Kap. Types and Typeclasses, Abschn. Typevariables]{Haskell11}.

Die Typklasse \emph{Eq} deklariert eine Funktion \emph{eq}\footnote{der Operator \emph{==} ist ein Alias fÃ¼r \emph{eq}}, um zwei Werte auf Gleichheit zu prÃ¼fen \cite[][S. 65]{Freeman17}. \emph{Eq} ist damit die Superklasse von \emph{Ord}, da ein Typ, um ein Mitglied von \emph{Ord} zu sein, zuerst ein Mitglied von \emph{Eq} sein sollte. Denn wenn \glqq\lstinline[language=purescript, columns=fixed]{a == b}\grqq{} unter den Gesetzen von \emph{Eq} gilt, sollte \glqq\lstinline[language=purescript, columns=fixed]{compare a b}\grqq{} zu \emph{EQ} ausgewertet werden. Diese Super- zu Subklassen Beziehung wird durch den rÃ¼ckwÃ¤rtsgewandten Doppelstrichpfeil in der Definition von Typklassen ausgedrÃ¼ckt \cite[][S. 77]{Freeman17}.

\subsection{Umsetzung von Typklassen in JavaScript am Beispiel der Typklasse Semiring}
\label{SemiringUmsetzung}
Wie in Abschnitt \glqq \ref{functionDefAndApp} \nameref{functionDefAndApp}\grqq{} angekÃ¼ndigt, wird das Additions-Beispiel an dieser Stelle wieder aufgegriffen und weiter ins Detail gegangen im Hinblick auf die dort genutzte Typklasse \emph{Semiring}. In Listing \ref{Data.SemiringClassPS} ist die Typklasse mit der Bezeichnung \emph{Semiring} aus dem Prelude Modul \emph{Data.Semiring} aufgefÃ¼hrt.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Auszug PureScript Prelude - Typklasse Data.Semiring, label=Data.SemiringClassPS]
class Semiring a where
	add  :: a -> a -> a
	zero :: a
	mul  :: a -> a -> a
	one  :: a
\end{lstlisting}

Die Typklasse \emph{Semiring} definiert vier Funktionen: die fÃ¼r unser Beispiel notwendige Addition, die Multiplikation und zwei konstante Funktionen \emph{zero} und \emph{one}. Wir mÃ¶chten an dieser Stelle nicht in die Mathematik abtauchen, allerdings sei gesagt, dass die 0 das neutrale\footnote{\href{https://de.wikipedia.org/wiki/Neutrales_Element}{https://de.wikipedia.org/wiki/Neutrales_Element}} Element in der  Addition und das absorbierende\footnote{\href{https://de.wikipedia.org/wiki/Absorbierendes_Element}{https://de.wikipedia.org/wiki/Absorbierendes_Element}} Element in der Multiplikation ist - wÃ¤hrend in der Multiplikation das neutrale Element die 1 ist. Damit bilden die Triple $(\mathbb{N}_0, +, 0)$ und $(\mathbb{N}, \cdot, 1)$ unter dem Assoziativgesetz jeweils einen Monoid\footnote{\href{https://de.wikipedia.org/wiki/Monoid}{https://de.wikipedia.org/wiki/Monoid}} und zusammen einen Halbring\footnote{\href{https://de.wikipedia.org/wiki/Halbring_(Algebraische_Struktur)}{https://de.wikipedia.org/wiki/Halbring_(Algebraische_Struktur)}}, wobei das Kommutativgesetz fÃ¼r die Addition zusÃ¤tzlich gilt und fÃ¼r beide das Distributivgesetz.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Auszug PureScript Prelude - Typinstanz Data.SemiringInt, label=Data.SemiringInstanceIntPS]
instance semiringInt :: Semiring Int where
	add = intAdd
	zero = 0
	mul = intMul
	one = 1
\end{lstlisting}

Ein Typ kann zu einer Instanz einer Typklasse werden, wenn er ihr spezifiziertes Verhalten unterstÃ¼tzt. Beispielsweise ist der Typ \emph{Int} eine Instanz (\glqq gehÃ¶rt zu\grqq{}) der Typklasse \emph{Eq}, da er vergleichbar ist und diese Typklasse die notwendigen Operationen fÃ¼r den Vergleich definiert  \cite[Kap. Making our own Types and Typeclasses, Abschn. Derived instances]{Haskell11}. Ebenso ist der Typ \emph{Int} eine Instanz der Typklasse \emph{Semiring}, wie in Listing \ref{Data.SemiringInstanceIntPS} zu sehen. Man kann dort erkennen wie die Typvariable \emph{a} durch den konkreten Typ \emph{Int} ersetzt wird und fÃ¼r die vier Funktionen der Typklasse deren typabhÃ¤ngige Implementierung angegeben ist. In PureScript werden Typinstanzen benannt (hier: \emph{semiringInt}), um die Lesbarkeit des korrespondierenden JavaScript-Codes zu erhÃ¶hen \cite[][S. 64]{Freeman17}.

In der Prelude gibt es neben der Datei Semiring.purs noch eine Datei Semiring.js - siehe Listing \ref{ForeignFunctionPS} und \ref{ForeignFunctionJS}. In Ersterer wird Ã¼ber PureScripts Foreign Function Interface ein Typ fÃ¼r die korrespondierende JavaScript-Funktion \emph{intAdd}\footnote{das binÃ¤re Oder dient dazu, dass auch bei Berechnungsungenauigkeiten das Ergebnis wieder eine korrekt gerundete Ganzzahl ist, da JavaScript Zahlen immer 64-Bit Gleitkommazahlen sind und die Genauigkeit fÃ¼r Ganzzahlen nur bis zu einer bestimmten LÃ¤nge garantiert wird \cite{w3schoolsJSNumbers18}} deklariert. In der zweiten Datei wird die Funktion in JavaScript definiert und exportiert.

\noindent\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=purescript, style=only-rect, caption= Foreign Function PS, label=ForeignFunctionPS]
	foreign import intAdd :: Int -> Int -> Int
	\end{lstlisting}
\end{minipage}% 
% 
\hfill% 
\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=javascript, style=only-rect, caption= Foreign Function JS, label=ForeignFunctionJS] 
	exports.intAdd = function (x) {
		return function (y) {
			/*jshint bitwise: false*/
			return x + y | 0;
		};
	};
	\end{lstlisting}
\end{minipage}
\hfill% 

Nach der Ãœbersetzung durch den Compiler landet der Inhalt der Datei Semiring.js in der Datei foreign.js im Ausgabeverzeichnis fÃ¼r die kompilierten Module. 

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Auszug aus Ã¼bersetzen Modul Data.Semiring, label=Data.SemiringJS]
// ../Data.Semiring/index.js
var $foreign = require("./foreign");

var Semiring = function (add, mul, one, zero) {
	this.add = add;
	this.mul = mul;
	this.one = one;
	this.zero = zero;
};

var semiringInt = new Semiring($foreign.intAdd, $foreign.intMul, 1, 0);

var add = function (dict) {
	return dict.add;
};
\end{lstlisting}

Wie in Listing \ref{Data.SemiringJS} zu sehen, wird fÃ¼r die Typklasse \emph{Semiring} ein Java-Script Objekt-Typ angelegt, indem eine Konstruktor-Funktion generiert wird \cite{w3schoolsJSObjectTypes18}. AnschlieÃŸend wird das Objekt \emph{semiringInt} erzeugt, welches in Abschnitt \glqq \ref{functionDefAndApp} \nameref{functionDefAndApp}\grqq{}, Listing \ref{FunctionJS} als \glqq Type Class Dictionary\grqq{} genutzt wurde und damit die Implementierung der Funktionen der Typklasse fÃ¼r die gewÃ¤hlte Instanz bereithÃ¤lt \cite[][S. 146--147]{Freeman17}. Dieses Listing wird an dieser Stelle durch Listing \ref{FunctionJS2} nochmals zur besseren Nachvollziehbarkeit wiederholt aufgefÃ¼hrt.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Funktionen in JavaScript - Kopie, label=FunctionJS2]
var Data_Semiring = require("../Data.Semiring");
var Prelude = require("../Prelude");

var addTwo = function (dictSemiring) {
	return function (a) {
		return function (b) {
			return Data_Semiring.add(dictSemiring)(a)(b);
		};
	};
};

var constant = addTwo(Data_Semiring.semiringInt)(2)(3);
\end{lstlisting}

Der Compiler umschlieÃŸt die Funktionsdefinitionen um eine weitere Funktion zur EinfÃ¼hrung dieses Type Class Dictionaries als weiteres Argument und ruft explizit die Funktion \emph{add} aus der Datei Data.Semiring/index.js auf, welche auf die Funktion \emph{add} aus dem Type Class Dictionary names \emph{semiringInt} zugreift. Mit diesem Mechanismus werden in PureScript Funktionen mit einem Typklassen-Constraint zur Laufzeit in JavaScript reprÃ¤sentiert \cite[][S. 148]{Freeman17}.

WÃ¼rde man anstatt \emph{add} die Funktion \emph{mul} aus der Typklasse nutzen, wÃ¼rde sich Zeile 7 wie folgt Ã¤ndern: \glqq\lstinline[language=javascript, columns=fixed]{return Data_Semiring.mul(dictSemiring)(a)(b);}\grqq{}. Rechnet man hingegen mit FlieÃŸkommazahlen anstatt Ganzzahlen, sÃ¤he Zeile 12 so aus: \glqq\lstinline[language=javascript, columns=fixed]{var constant = addTwo(Data_Semiring.semiringNumber)(2.0)(3.0);}\grqq{}. Das Ãœbersetzungsmuster scheint also bestehen zu bleiben und es wird entweder nur eine andere Funktion aus dem Type Class Dictionary gewÃ¤hlt oder ein anderes Typ Class Dictionary, durch die Verwendung einer anderen Typklasse in PureScript, erzeugt.

\subsection{BestÃ¤tigung des Ãœbersetzungsmusters von Typklassen}
Am Anfang dieses Kapitels wurden Typklassen am Beispiel der Typklasse \emph{Ord} erlÃ¤utert. In diesem Unterabschnitt soll durch den Vergleich von zwei Werten eines bestimmten Typs das Ãœbersetzungsmuster aus dem vorherigen Unterabschnitt \ref{SemiringUmsetzung} bestÃ¤tigt werden. Durch die Listings \ref{TypeClassOrdPS} und \ref{TypeClassOrdJS} ist erkennbar, wie die Benutzung der Typklasse \emph{Ord} zu dem gleichen Ãœbersetzungsmuster wie bei der Typklasse \emph{Semiring} fÃ¼hrt.

Es wird logischerweise ein anderes Type Class Dictionary (\emph{ordInt}) genutzt und andere Funktionen aufgerufen, da in Listing \ref{TypeClassOrdPS} die GrÃ¶ÃŸer-Als-Vergleichsoperation (>) genutzt wird. Das Muster ist jedoch identisch. Auf Implementierungsdetails abseits der gezeigten Top-Ebene der Ãœbersetzung sei an dieser Stelle verzichtet.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Beispiel mit Typklasse Ord in PureScript, label=TypeClassOrdPS]
module Main where

import Prelude

compGT x y = y > x

constant = compGT 2 3
\end{lstlisting}

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Ãœbersetzung nach JavaScript, label=TypeClassOrdJS]
var Data_Ord = require("../Data.Ord");
var Prelude = require("../Prelude");

var compGT = function (dictOrd) {
	return function (x) {
		return function (y) {
			return Data_Ord.greaterThan(dictOrd)(y)(x);
		};
	};
};

var constant = compGT(Data_Ord.ordInt)(2)(3);
\end{lstlisting}

\subsection{Wenn Compileroptimerungen das Ãœbersetzungsmuster durchbrechen}
Das vorgestellte Ãœbersetzungsmuster wird vom PureScript Compiler nicht strikt verfolgt. Es gibt Situation, wo er Optimierungen ansetzt. Eine wird im Folgenden vorgestellt. 

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Ãœbersetzung nach JavaScript mit anderem Muster, label=TypeClassOrdOtherPatternJS]
var Data_Ord = require("../Data.Ord");
var Prelude = require("../Prelude");

var compGT = function (x) {
	return function (y) {
		return y > x;
	};
};

var constant = compGT(2)(3);
\end{lstlisting}

Wenn man Funktionen mit einer Typdeklaration ausstattet, anstatt, dass der Comiler den Typ durch Typinferenz herausfinden muss, wird wenn mÃ¶glich ein optimiertes  Ãœbersetzungsmuster genutzt. In Listing \ref{TypeClassOrdOtherPatternJS} ist dargestellt, wie das vorgestellte Beispiel mit der Typklasse Ord aus Listing \ref{TypeClassOrdPS} Ã¼bersetzt wird, wenn man eine Typdeklaration wie folgt angibt: \glqq\lstinline[language=purescript, columns=fixed]{compGT :: Int -> Int -> Boolean}\grqq{}. 

Es entfÃ¤llt vollstÃ¤ndig die Nutzung des Type Class Dictionaries und der damit verbundenen Funktionsdefinitionen und -applikationen. Im Beispiel der Addition, in Verbindung mit der Typklasse \emph{Semiring} aus Listing \ref{FunctionPS}, verhÃ¤lt es sich Ã¤hnlich. Es wird mit Typdeklaration gemÃ¤ÃŸ des Musters von Listing \ref{TypeClassOrdOtherPatternJS}  Ã¼bersetzt und der Code zur Addition (\glqq\lstinline[language=javascript, columns=fixed]{return a + b | 0;}\grqq{}), der ursprÃ¼nglich Ã¼ber einen Foreign Function Import genutzt wurde (Listing \ref{ForeignFunctionJS}), wird direkt in die innerste, durch Currying erzeugte, Funktion gesetzt.

\subsection{Lessons Learnd}
\begin{itemize}
	\item Typklassen in PureScript werden als Object Types (Klassen) in JavaScript abgebildet (sind aber vom Konzept keine Klassen im Sinne von OOP!).
	\item Typinstanzen in PureScript sind Objekte in JavaScript, welche in diesem Kontext auch als Type Class Dictionaries bezeichnet werden. Sie bekommen bei Erzeugung die entsprechenden Funktionen Ã¼ber den Konstruktor Ã¼bergeben.
	\item Die Bezeichnungen von Typklassen oder Typinstanzen werden ebenso fÃ¼r ihre Pendants in JavaScript genutzt. Dabei tragen die Bezeichner einer Typinstanz im ersten Teil immer den Namen ihrer Typklasse, gefolgt vom Datentyp fÃ¼r den sie stehen.
	\item Bei Gebrauch von Typinferenz erzeugt der Compiler Code, in dem Type Class Dictionaries genutzt werden und die fÃ¼r die zusÃ¤tzliche Ã¤uÃŸerste Funktion beim Currying von Funktionen verantwortlich sind.
	\item Funktionen mit Typdeklaration werden vom Compiler, sofern mÃ¶glich, ohne die Nutzung von Type Class Dictionaries Ã¼bersetzt.
\end{itemize}


\chapter{Rekursion und Funktionen hÃ¶herer Ordnung}
Rekursion ist in der funktionalen Programmierung die Basistechnik schlechthin um wiederholende Operationen auszufÃ¼hren. In rein funktionalen Sprachen wie PureScript gibt es keine verÃ¤nderlichen ZustÃ¤nde und damit auch keine Schleifen, wie man sie aus der imperativen Programmierung kennt. Das begrÃ¼ndet sich aus der Tatsache, dass man in funktionalen Sprachen Berechnungen durchfÃ¼hrt, indem man vornehmlich beschreibt was etwas ist, anstatt wie man etwas macht \cite[][S. 31--32]{Freeman17}. 

In diesem Kapitel wird demonstriert, wie unterschiedliche Formen der Rekursion nach JavaScript Ã¼bersetzt werden und welche Optimierungen der Compiler dabei durchfÃ¼hrt. DarÃ¼ber hinaus wird eine prominente Funktion (\emph{fold}) aus der funktionalen Welt vorgestellt, welche zwar das Konzept der Rekursion intern nutzt, aber fÃ¼r die Anwendung durch den Nutzer davon abstrahiert.

\section{Rekursion und deren Ãœbersetzung nach JavaScript}
In diesem Abschnitt soll einerseits veranschaulicht werden, wie man Rekursion in PureScript ausdrÃ¼ckt und andererseits, wie sie in JavaScript vom Compiler umgesetzt wird. Dazu werden zwei Beispiele herangezogen, die Definition der Fibonacci-Funktion und die rekursive Definition der Summenberechnung Ã¼ber eine Liste. Wie im Abschnitt der Algebraischen Datentypen bereits erwÃ¤hnt, ist eine Liste ein ADT, der Ã¼ber sich selbst rekursiv definiert ist und damit ist die Struktur der Liste prÃ¤destiniert fÃ¼r Rekursion in Verbindung mit Pattern Matching. Im Beispiel des Listings \ref{RekursionPS} wird die Listendefinition aus der Bibliothek von PureScript genutzt. FÃ¼r unsere jetzigen Zwecke ist es hinreichend, sie sich so vorzustellen, wie wir sie in Listing \ref{ADTPS} definiert haben.

In Listing \ref{RekursionPS} ist zunÃ¤chst die Fibonacci-Funktion (\lstinline[language=purescript, columns=fixed]{fib}) und anschlieÃŸend die Summenfunktion (\lstinline[language=purescript, columns=fixed]{sum}) definiert, gefolgt von einem Verwendungsbeispiel, deren Resultate in Konstanten abgelegt werden. Der Wert von \emph{resFib} entspricht 89 und von \emph{resSum} 6 im Beispiel. Bei bspw. \emph{sum} ist zu beachten, dass die Angabe von Mustern, um zwei Strukturen zu vergleichen, eingesetzt werden, um die Abbruchbedingung und Berechnungsvorschrift fÃ¼r die Rekursion zu definieren. Dies entspricht den Wertkonstruktoren des ADT's der Liste - eine Liste kann entweder leer sein oder einen Kopf, gefolgt von einem Rest haben, wobei der Rest wieder eine Liste ist. Der im Pattern verwendete Doppelpunkt ist ein Infix-Alias fÃ¼r den Wertkonstruktor \emph{Cons}. Die Summe der Elemente einer leeren Liste ist 0, die Summe einer nicht leeren Liste ist der Wert des Kopfs der Liste (des ersten Elements) und der Wert der Summe Ã¼ber den Rest der Liste.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Rekursion in PureScript, label=RekursionPS]
module Main where

import Prelude
import Data.List

fib :: Int -> Int
fib 0 = 1
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)

sum :: List Int -> Int
sum Nil = 0
sum (head : tail) = head + sum (tail)

resFib = fib 10
resSum = sum (Cons 1 (Cons 2 (Cons 3 Nil)))
\end{lstlisting}

Die Summenfunktion ist in dieser Definitionsart eine linear rekursive Funktion. Das heiÃŸt, sie hat eine nachhÃ¤ngende Operation neben dem rekursiven Aufruf - in diesem Fall die Addition des VorgÃ¤ngerelements. Der PureScript Compiler Ã¼bersetzt diese Art von Funktionen wie in Listing \ref{RekursionJS} dargestellt. Rekursive Funktionen, bei denen die nachhÃ¤ngende Operation ein weiterer rekursiver Aufruf ist, werden auf die gleiche Weise Ã¼bersetzt und als allgemeine rekursive oder einfach nur rekursive Funktionen bezeichnet, da sie keiner BeschrÃ¤nkung unterliegen. Eine Funktion dieser Form ist die Fibonacci-Funktion. In Listing \ref{RekursionJS} sei wegen der LÃ¤nge auf die Imports und Aufrufbeispiele verzichtet.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Ãœbersetzung von Rekursion nach JavaScript, label=RekursionJS]
var fib = function (v) {
	if (v === 0) {
		return 1;
	};
	if (v === 1) {
		return 1;
	};
	return fib(v - 1 | 0) + fib(v - 2 | 0) | 0;
};

var sum = function (v) {
	if (v instanceof Data_List_Types.Nil) {
		return 0;
	};
	if (v instanceof Data_List_Types.Cons) {
		return v.value0 + sum(v.value1) | 0;
	};
	throw new Error("Failed pattern match at Main line 15, column 1 - line 15, column 23: " + [ v.constructor.name ]);
};
\end{lstlisting}

Beide Funktionen haben im Wesentlichen das gleiche Ãœbersetzungsmuster. Das Pattern Matching wird in If-Abfragen umgewandelt. Die Abbruchbedingungen werden allesamt auf diese Weise definiert. Bei der Summenfunktion kommt die Definition eines Errors hinzu, falls die Eingabe nicht das Muster der Datenstruktur Liste  erfÃ¼llt. Wenn man von den Bezeichnungen einmal absieht, entspricht die Ãœbersetzung von Rekursion ziemlich genau der Form, wie sie ein Programmierer manuell in JavaScript verwendet hÃ¤tte.

\section{Optimierte Ãœbersetzung von Endrekursion}
Die Ã¼bliche Umsetzung von Rekursion in Programmiersprachen wie JavaScript hat einen entscheidenden Makel. Wenn die Eingaben zu groÃŸ werden, die Verschachtlung von Funktionsaufrufen zu tief und der Stack dann seine maximale GrÃ¶ÃŸe Ã¼berschreitet, endet dies in einem Fehler - StackOverflow. Um unbegrenzte Eingabe bei Rekursion dennoch nutzen zu kÃ¶nnen, wird eine Technik namens \glqq Tail Recursion Optimization\grqq{} (kurz: TCO) von PureScript eingesetzt. Die rekursive Funktion wird bei der Ãœbersetzung in eine while-Schleife umgewandelt, was den Speicherplatzverbrauch von der Rekursionstiefe unabhÃ¤ngig macht, nÃ¤mlich konstant. Dies gelingt nur, wenn die rekursive Funktion endrekursiv ist. Das heiÃŸt dem rekursiven Aufruf folgen keine weiteren Operationen, weshalb kein neuer Stackframe allokiert werden mÃ¼sste. Viele linear rekursive Funktionen kÃ¶nnen in endrekursive Funktionen umformuliert werden, was diese Optimierungstechnik trotz der EinschrÃ¤nkung der Endrekursion wertvoll macht \cite[][S. 42--43]{Freeman17}.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Endrekursion in PureScript, label=EndrekursionPS]
module Main (sumTailRec) where

import Prelude
import Data.List

sumTailRec :: List Int -> Int
sumTailRec lst = sumTailRec' lst 0

sumTailRec' :: List Int -> Int -> Int 
sumTailRec' Nil acc = acc
sumTailRec' (head : tail) acc = sumTailRec' (tail) (head + acc)
\end{lstlisting}

Listing \ref{EndrekursionPS} zeigt die Umformulierung der Summenfunktion in eine endrekursive Form. Eine gÃ¤ngige Technik zur Umformung ist die Nutzung eines akkumulierenden Parameters. Bei der Funktionsdefinition wird ein zusÃ¤tzlicher  Parameter verwendet, durch den die Ergebnisse eines jeden rekursiven Aufrufs aufgehÃ¤uft werden, anstatt dafÃ¼r den Return Value der Funktion zu nutzen \cite[][S. 43]{Freeman17}. Dadurch, dass die Berechnung und deren Resultat Ã¼ber den Parameter Ã¼ber die rekursiven Aufrufe hinweg mitgezogen wird, muss der Stackframe im Gegensatz zu einer linear rekursiven Funktion nicht aufbewahrt werden, um beim Aufstieg aus der Rekursion die Berechnungen mit den jeweiligen Werten des primÃ¤ren Parameters durchzufÃ¼hren. Damit die Funktion fÃ¼r den Anwender die gleiche Signatur behÃ¤lt, wird meist die eigentliche rekursive Berechnung in einer  auÃŸerhalb des Moduls nicht sichtbaren Hilfsfunktion ausgefÃ¼hrt.

In Listing \ref{EndrekursionJS} ist die Ãœbersetzung der endrekursiven Summenfunktion auf Listen dargestellt. Die AbkÃ¼rzung \emph{tco} in Variablennamen steht mutmaÃŸlich fÃ¼r \glqq Tail Call Optimization\grqq{}\footnote{\href{https://en.wikipedia.org/wiki/Tail_call}{https://en.wikipedia.org/wiki/Tail_call}}.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption= Ãœbersetzung von Endrekursion nach JavaScript, label=EndrekursionJS]
var sumTailRec$prime = function ($copy_v) {
	return function ($copy_acc) {
		var $tco_var_v = $copy_v;
		var $tco_done = false;
		var $tco_result;
		function $tco_loop(v, acc) {
			if (v instanceof Data_List_Types.Nil) {
				$tco_done = true;
				return acc;
			};
			if (v instanceof Data_List_Types.Cons) {
				$tco_var_v = v.value1;
				$copy_acc = v.value0 + acc | 0;
				return;
			};
			throw new Error("<pattern error message skipped by author>");
		};
		while (!$tco_done) {
			$tco_result = $tco_loop($tco_var_v, $copy_acc);
		};
		return $tco_result;
	};
};

var sumTailRec = function (lst) {
	return sumTailRec$prime(lst)(0);
};
\end{lstlisting}

Wir fangen bei der ErklÃ¤rung der Variablen an. Die ErlÃ¤uterung basiert auf einem Beispielaufruf mit einer Liste der Form: \lstinline[language=javascript, columns=fixed]{Cons 1 (Cons 2 (Cons 3 Nil))}. Durch den Aufruf der Funktion \emph{sumTailRec} wird die Liste an die Funktion \emph{sumTailRec\$prime} zzgl. des Akkumulatorwerts \lstinline[language=javascript, columns=fixed]{0} Ã¼bergeben (Zeile 25 - 27). Die Funktion \emph{sumTailRec\$prime} enthÃ¤lt die eigentliche GeschÃ¤ftslogik und Ãœbersetzung der Endrekursion in eine while-Schleife. Dazu definiert sie zwei Argumentvariablen aufgrund des Curryings und drei Variablen innerhalb der innersten Funktion (Zeile 1 - 5). Nachfolgende AufzÃ¤hlung beschreibt die Intension hinter diesen fÃ¼nf Variablen und deren Initialisierung fÃ¼r unseren Beispielaufruf.

\begin{description}
	\item[\$copy_v:]  enthÃ¤lt die initiale Liste, die als Argument Ã¼bergeben wurde, Ã¤ndert seinen Werte nie und ist fÃ¼r die weitere Betrachtung nicht mehr von Belang - \lstinline[language=javascript, columns=fixed]{Cons 1 (Cons 2 (Cons 3 Nil))}
	\item[\$copy_acc:] enthÃ¤lt den initialen Akkumulatorwert und wird bei jedem Schleifendurchlauf mit dem neuen Akkumulatorwert beschrieben - \lstinline[language=javascript, columns=fixed]{0}
	\item[\$tco_var_v:] bekommt initial die Liste aus \emph{\$copy_v} Ã¼bergeben und wird bei jedem Schleifendurchlauf mit der kÃ¼rzer werdenden Liste beschrieben - \lstinline[language=javascript, columns=fixed]{Cons 1 (Cons 2 (Cons 3 Nil))}
	\item[\$tco_done:] wird als Schleifenbedingung (Flag) und damit zum Ausstieg aus dieser genutzt, sobald die Summe vollstÃ¤ndig berechnet wurde - \lstinline[language=javascript, columns=fixed]{false}
	\item[\$tco_result:] enthÃ¤lt im letzten Schleifendurchlauf die endgÃ¼ltige Summe und gibt sie anschlieÃŸend zurÃ¼ck bei Funktionsende - \lstinline[language=javascript, columns=fixed]{undefined}
\end{description}

Im Anschluss zu diesen fÃ¼nf Variablen wird die Funktion \emph{\$tco_loop} definiert, welche die eigentliche GeschÃ¤ftslogik und Pattern Matching und Berechnungsvorschriften enthÃ¤lt (Zeile 6 bis 17). Sie gleicht der naiven Ãœbersetzung der Summenfunktion in Listing \ref{RekursionJS} und beschreibt, was spÃ¤ter wiederholt ausgefÃ¼hrt werden soll.

Darauf folgt eine while-Schleife, welche die Funktion \emph{\$tco_loop} mit den Variablen \emph{\$tco_var_v} und \emph{\$copy_acc} aufruft (Zeile 18 - 20). Dies wird solange wiederholt, bis die Variable \emph{\$tco_done} aus der Funktion \emph{\$tco_loop} heraus auf \lstinline[language=javascript, columns=fixed]{true} gesetzt wurde. Zum Abschluss bekommt \emph{\$tco_result} die endgÃ¼ltige Summe zugewiesen, die Schleife wird verlassen und der Wert von \emph{\$tco_result} zurÃ¼ckgegeben.

Nachdem alle beteiligten Komponenten erklÃ¤rt wurden, kommen wir nun zur Dynamik des Aufrufs. Nebenstehende AufzÃ¤hlung begleitet die folgenden ErlÃ¤uterungen fÃ¼r den Beispielaufruf mit einer Liste von \lstinline[language=javascript, columns=fixed]{Cons 1 (Cons 2 (Cons 3 Nil))}. Die AufzÃ¤hlung zeigt, welche Werte die Variablen nach einem Schleifendurchlauf und Aufruf der Funktion \emph{\$tco_loop} haben. Variablen, die in einem Schleifendurchlauf keine WertverÃ¤nderung erfahren haben, sind nicht aufgefÃ¼hrt.

\begin{wrapfigure}[12]{r}{.52\textwidth}
	\vspace{-0.5cm}
	\begin{enumerate}
		\item 
		\begin{description}
			\item[\$tco_var_v:] \lstinline[language=javascript, columns=fixed]{Cons 2 (Cons 3 Nil)}
			\item[\$copy_acc:] \lstinline[language=javascript, columns=fixed]{1}
			\item[\$tco_result:] \lstinline[language=javascript, columns=fixed]{undefined}
		\end{description}
		\item 
		\begin{description}
			\item[\$tco_var_v:] \lstinline[language=javascript, columns=fixed]{Cons 3 Nil}
			\item[\$copy_acc:] \lstinline[language=javascript, columns=fixed]{3}
			\item[\$tco_result:] \lstinline[language=javascript, columns=fixed]{undefined}
		\end{description}
		\item 
		\begin{description}
			\item[\$tco_var_v:] \lstinline[language=javascript, columns=fixed]{Nil}
			\item[\$copy_acc:] \lstinline[language=javascript, columns=fixed]{6}
			\item[\$tco_result:] \lstinline[language=javascript, columns=fixed]{undefined}
		\end{description}
		\item
		\begin{description}
			\item[\$tco_done:] \lstinline[language=javascript, columns=fixed]{true}
			\item[\$tco_result:] \lstinline[language=javascript, columns=fixed]{6}
		\end{description}
	\end{enumerate}
\end{wrapfigure}

Bei jedem Schleifendurchlauf wird die Funktion \emph{\$tco_loop} mit der immer kÃ¼rzer werdenden Liste (\emph{\$tco_var_v}) und dem aktuellen Summenwert (\emph{\$copy_acc}) aufgerufen. Beide Variablen werden bei jedem Schleifendurchlauf aktualisiert, bis die Liste leer ist, die Abbruchbedingung greift und der Wert des Akkumulators (\emph{\$copy_acc}) einmalig am Ende in \emph{\$tco_result} gespeichert wird, bevor die Schleife verlassen wird. 

Wenn die Liste nicht leer ist (Zeile 11 - 15), wird die zustandsbehaftete Variable \emph{\$tco_var_v}, welche mit der Eingabeliste initialisiert ist, auf den Rest der Liste (\emph{v.value1}) gesetzt. Die Variable nÃ¤hert sich also bei jedem Schleifendurchlauf dem Ende der Liste und damit der Abbruchbedingung an, indem der Kopf \glqq abgeschnitten\grqq{} wird. Die wechselnden Zwischensummen werden in der Akkumulator Variable \emph{\$copy_acc} abgelegt. Daraufhin wird nichts zurÃ¼ckgegeben\footnote{\label{initUndefined}genau genommen wird bei einem \lstinline[language=javascript, columns=fixed]{return} ohne nachfolgenden Ausdruck \lstinline[language=javascript, columns=fixed]{undefined} zurÃ¼ckgegeben und eine nicht initialisierte Variable ist implizit ebenso mit \lstinline[language=javascript, columns=fixed]{undefined} belegt \cites{w3schoolsJSReturnStatement18}{w3schoolsJSUndefined18}}.

Wenn die Liste leer ist (Abbruchbedingung), wird nicht nur der Endwert der Summe zurÃ¼ckgegeben, sondern ebenso das Flag \emph{\$tco_done} von \lstinline[language=purescript, columns=fixed]{false} auf \lstinline[language=purescript, columns=fixed]{true} gesetzt. Dieses wird spÃ¤ter in Zeile 18 dazu genutzt, die while-Schleife zu verlassen und anschlieÃŸend das Endergebnis (\emph{\$tco_result}) zurÃ¼ckzugeben.

Die Variable \emph{\$tco_result} ist also bis auf diesen Schlussmoment uninitialisiert\footref{initUndefined} und im Gegensatz zu Listing \ref{RekursionJS} wird fÃ¼r den Fall, dass man noch nicht am Ende der Liste angelangt ist, nicht die Zwischensumme stÃ¤ndig durch den Funktionsaufruf zurÃ¼ckgegeben, sondern nur einmal beim ErfÃ¼llen der Abbruchbedingung, wo es dann die Endsumme ist. Die sich verÃ¤ndernde Liste und Summe werden Ã¼ber die Nutzung von Seiteneffekten, mittels auÃŸerhalb der innersten Funktion (\emph{\$tco_loop}) definierten Variablen, geschrieben und gelesen. Im letzten Schleifendurchlauf enthÃ¤lt \emph{\$copy_acc} die Endsumme, Ã¼bergibt sie an den Parameter \emph{acc}, welcher durch den Fall der Abbruchbedingung als Returnwert der innersten Funktion wiederum \emph{\$tco_result} zugewiesen wird, um ihn schlussendlich als Endergebnis des gesamten Aufrufs zurÃ¼ck zu liefern.

\paragraph{Aber die Optimierung von Endrekursion hat auch seine Grenzen.}   Wechselseitig endrekursive Funktionen werden in Purescript nicht optimiert bei der Ãœbersetzung. Beispielsweise werden die beiden endrekursiven Funktionen aus Listing \ref{WechselEndrekursionPS} auch in JavaScript durch Rekursion reprÃ¤sentiert. Auf die genaue Ãœbersetzung sei an dieser Stelle verzichtet. Sie gestaltet sich analog zu der aus Listing \ref{RekursionJS}.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Wechselseitige Endrekursion in PureScript, label=WechselEndrekursionPS]
module Main where

import Prelude

isEven :: Int -> Boolean
isEven 0 = true
isEven 1 = false
isEven n = isOdd (n - 1)

isOdd :: Int -> Boolean
isOdd 0 = false
isOdd 1 = true
isOdd n = isEven (n - 1)
\end{lstlisting}

\section{Funktionen hÃ¶herer Ordnung}
Nachdem wir in den letzten Abschnitten Rekursion als einziges Wiederholungskonzept in rein funktionalen Sprachen kennengelernt und gesehen haben, wie effizient Endrekursion nach JavaScript Ã¼bersetzt wird, erscheint es zunÃ¤chst unumgÃ¤nglich sich der rekursiven Programmierung in der Praxis bedienen zu mÃ¼ssen. Allerdings sind in der funktionalen Welt Funktionen bereits vorhanden, mit denen sich Aufgaben wie die Berechnung der Summe aus den Elementen einer Liste formulieren lassen, ohne explizit Rekursion nutzen zu mÃ¼ssen. Die hier gemeinten Funktionen werden Funktionen hÃ¶herer Ordnung genannt. Sie zeichnen sich dadurch aus, dass sie eine Funktion als Argument annehmen oder eine Funktion zurÃ¼ckgeben kÃ¶nnen. Die Summe der Elemente einer Liste kann bspw. mit der Funktion \emph{fold} realisiert werden, die in allen gÃ¤ngigen funktionalen Programmiersprachen in etwa diesen Namen trÃ¤gt, wodurch  die Absicht des eigenen Quellcodes fÃ¼r andere Programmierer viel schneller zu erfassen ist, als wenn man blanke Rekursion nutzen wÃ¼rde \cite[][S. 44]{Freeman17}. In Listing \ref{FoldSumPS} wird die Definition der Summenfunktion unter zu Hilfenahme von \emph{fold} demonstriert und die Funktion genauer erklÃ¤rt. Bevor wir allerdings dazu kommen, sei noch ein weiterer Vorteil von Funktionen hÃ¶herer Ordnung erwÃ¤hnt. Es ist mit ihnen leicht die GeschÃ¤ftslogik vom Kontext zu trennen - dem Code, der z.B. nÃ¶tig ist, um Ã¼ber eine bestimmte Datenstruktur zu traversieren. Das heiÃŸt, eine Funktion wie \emph{fold} definiert intern wie z.B. eine Liste durchlaufen werden soll, und nimmt die eigentliche Berechnungsfunktion als Argument an. Dies fÃ¼hrt dazu, dass wir ohne groÃŸen Aufwand und Coderedundanzen, in diesem Fall nicht nur die Summe, sondern bspw. auch das Produkt der Elemente berechnen kÃ¶nnten. In OO-Sprachen, in denen Funktionen keine First-Class-Citizens\footnote{in denen sie nicht wie andere Werte Typen haben kÃ¶nnen, und nicht wie andere Werte als Funktionsargument genutzt werden kÃ¶nnen} sind, realisiert man so etwas durch das Entwurfsmuster Strategie.

\begin{wrapfigure}[8]{r}{.45\textwidth}
	\begin{lstlisting}[aboveskip=-1em, language=purescript, caption=Typklasse Foldable, label=FoldablePS]
	class Foldable f where
		foldr :: forall a b. (a -> b -> b) -> b -> f a -> b
		foldl :: forall a b. (b -> a -> b) -> b -> f a -> b
	\end{lstlisting}
\end{wrapfigure}

Alle Datenstrukturen, die man falten kann, sind Instanzen der Typklasse \emph{Foldable}. In Listing \ref{FoldablePS} ist diese mit zwei wesentlichen Funktionsdeklarationen auszugsweise dargestellt. Der Vorgang des Faltens beschreibt einen Prozess, indem eine Datenstruktur von Werten zu einem Wert reduziert wird. Wie dieser Prozess gestaltet wird, entscheidet eine Funktion, die als Argument der \emph{fold}-Funktion Ã¼bergeben wird. Die Funktion \emph{foldl} faltet die Datenstruktur von links aus gesehen zu einem Wert und \emph{foldr} von rechts aus \cites{HaskellWikiFold18}[][S. 40--42]{Freeman17}. Beide Faltfunktionen nehmen als erstes Argument eine Funktion an. Diese nimmt einen Wert vom Typ \emph{a} an und einen Wert vom Typ \emph{b}. Ersterer ist ein Wert aus der Datenstruktur, die als drittes Argument angeben wird (\emph{f a})\footnote{\emph{f} steht fÃ¼r einen Funktor eines beliebigen Typs \emph{a} (Typkonstruktor). Dazu kommen wir im nÃ¤chsten Kapitel detailliert. FÃ¼r den Moment stellen wir uns \emph{f} einfach als Datenstruktur oder Container vor.}. Zweiterer dient als Akkumulator fÃ¼r jeden Berechnungsschritt und wird letztlich von der Faltfunktion zurÃ¼ckgegeben. ZusÃ¤tzlich muss ein Initialwert fÃ¼r den Akkumulator als zweites Argument Ã¼bergeben werden. Je nach Berechnungsintension ist der Akkumulatorwert ein neutrales Element in der jeweiligen Berechnung. Abbildung \ref{fig:RightLeftFold} veranschaulicht das Falten anhand von einer Liste von Ganzzahlen (hier 1-5) als Datenstruktur. Der Doppelpunkt steht fÃ¼r \emph{Cons}, \lstinline[language=purescript, columns=fixed]{[]} beschreibt die leere Liste (\emph{Nil}), \emph{z} ist der Akkumulatorwert und \emph{f} die Funktion, welche die Berechnung bei jedem Faltschritt definiert.

\begin{figure}[ht!]
	\begin{center}
		\subfigure[Falten von rechts]{%
			\label{fig:RightFold}
			\includegraphics[width=0.4\textwidth]{pictures/Right-fold-transformation.png}
		}%
		\subfigure[Falten von links]{%
			\label{fig:LeftFold}
			\includegraphics[width=0.4\textwidth,scale=0.5]{pictures/Left-fold-transformation.png}
		}%		
	\end{center}
	\caption{%
		Veranschaulichung des Faltens anhand von Listen \cite{HaskellWikiFold18}
	}%
	\label{fig:RightLeftFold}
\end{figure}

Das Faltbeispiel der Summen- und Produktfunktion aus Listing \ref{FoldSumPS} ist semantisch kompatibel mit Abbildung \ref{fig:RightLeftFold}, auch wenn Arrays statt Listen angewendet werden. Sowohl die Summe als auch das Produkt werden Ã¼ber \emph{foldl} ausgedrÃ¼ckt. Als Funktion und Akkumulator dient bei der Summe die binÃ¤re Funktion \lstinline[language=purescript, columns=fixed]{+} und \lstinline[language=purescript, columns=fixed]{0} als neutrales Element, bei dem Produkt \lstinline[language=purescript, columns=fixed]{*} und \lstinline[language=purescript, columns=fixed]{1}. 
\newpage
\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Falten in PureScript, label=FoldSumPS]
module Main where

import Prelude
import Data.Foldable

sum :: forall a f. Foldable f => Semiring a => f a -> a
sum = foldl (+) zero

product :: forall a f. Foldable f => Semiring a => f a -> a
product = foldl (*) one

resSum = sum [1, 2, 3]
resPro = product [1, 2, 3]
\end{lstlisting}

Listing \ref{FoldSumJS} zeigt am Beispiel des Faltens, wie Funktionen hÃ¶herer Ordnung nach JavaScript Ã¼bersetzt werden kÃ¶nnen. Da es sich bei \emph{Foldable} um eine Typklasse handelt, ist das Ãœbersetzungsmuster gemÃ¤ÃŸ des in Abschnitt \glqq \ref{lbl:Typeclasses} \nameref{lbl:Typeclasses}\grqq{} beschriebenen.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Falten in JavaScript, label=FoldSumJS]
var Prelude = require("../Prelude");
var Data_Foldable = require("../Data.Foldable");
var Data_Semiring = require("../Data.Semiring");

var sum = function (dictFoldable) {
	return function (dictSemiring) {
		return Data_Foldable.foldl(dictFoldable)(Data_Semiring.add(dictSemiring))(Data_Semiring.zero(dictSemiring));
	};
};

var product = function (dictFoldable) {
	return function (dictSemiring) {
		return Data_Foldable.foldl(dictFoldable)(Data_Semiring.mul(dictSemiring))(Data_Semiring.one(dictSemiring));
	};
};

var resSum = sum(Data_Foldable.foldableArray)(Data_Semiring.semiringInt)([ 1, 2, 3 ]);
var resPro = product(Data_Foldable.foldableArray)(Data_Semiring.semiringInt)([ 1, 2, 3 ]);
\end{lstlisting}

Es wird also analog die Typklasse \emph{Foldable} aus PureScript als Object Type (Klasse) in JavaScript reprÃ¤sentiert. Die Typinstanz fÃ¼r die Datenstruktur Array ist ein Objekt (Type Class Dictionary) mit der Bezeichnung \emph{foldableArray}, welches Ã¤hnlich wie in Abschnitt \ref{lbl:Typeclasses} Listing \ref{Data.SemiringJS} beim Objekt \emph{semiringInt} die Implementierung des Faltens als Foreign Function Import zugewiesen bekommt. Dieses Type Class Dictionary wird als Argument Ã¼bergeben, zzgl. einer Berechnungsfunktion und der Datenstruktur (Listing \ref{FoldSumJS}, je Zeile 17 und 18). Listing \ref{FoldFFIJS} zeigt, wie das Falten in JavaScript implementiert ist.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Falten als Native-Implementierung in JavaScript, label=FoldFFIJS]
exports.foldrArray = function (f) {
	return function (init) {
		return function (xs) {
			var acc = init;
			var len = xs.length;
			for (var i = len - 1; i >= 0; i--) {
				acc = f(xs[i])(acc);
			}
			return acc;
		};
	};
};

exports.foldlArray = function (f) {
	return function (init) {
		return function (xs) {
			var acc = init;
			var len = xs.length;
			for (var i = 0; i < len; i++) {
				acc = f(acc)(xs[i]);
			}
			return acc;
		};
	};
};
\end{lstlisting}

Es wird deutlich, dass das Falten nicht mit Rekursion, sondern Schleifen umgesetzt ist. Den Unterschied zwischen von links und rechts Falten, erkennt man an den jeweiligen SchleifenkÃ¶pfen. Das Array \emph{xs} wird einmal von rechts und einmal von links durchlaufen. Der Parameter \emph{init} hÃ¤lt den Initialwert des Akkumulators, dessen Variable \emph{acc} heiÃŸt.

Die Ãœbergabe und RÃ¼ckgabe von Funktionen in Funktionen hÃ¶herer Ordnung gestaltet sich als intuitiv, denn in JavaScript sind Funktionen ebenfalls First-Class-Citizens. Die Berechnungsfunktion namens \emph{f} wird einfach als Argument Ã¼bergeben und in den Zeilen 7 und 20 jeweils mit dem aktuellen Array-Element und Akkumulatorwert aufgerufen.


\chapter{Funktoren, Applicatives, Monaden}
In der Prelude werden drei Typklassen definiert, die wesentlich fÃ¼r die Handhabung von Seiteneffekten in PureScript sind -  \emph{Functor}, \emph{Applicative} und \emph{Monad} \cite[][S. 68]{Freeman17}. 

\begin{wrapfigure}{r}{0.5\textwidth} % Inline image example
	\begin{center}
		\includegraphics[width=0.45\textwidth]{Pictures/value-apply.png}
	\end{center}
	\caption{Wert und einfache Funktionsanwendung mit ihm \cite[][]{AdityaBhargava13}}
	\label{fig:SimpleValue}
\end{wrapfigure}

Rein funktionale Programmiersprachen kennen keine Seiteneffekte - zumindest keine Unkontrollierten. Das bedeutet Funktionen kÃ¶nnen \glqq nicht einfach so\grqq{} einen Zustand, wie den Inhalt einer Variable, Ã¤ndern. Sie liefern bei gleichen Parametern, bei jedem Aufruf, immer das gleiche Resultat (siehe Abbildung \ref{fig:SimpleValue}). Ein wesentlicher Vorteil von dieser selbst auferlegten BeschrÃ¤nkung ist, dass es viel leichter als in imperativen Sprachen ist, BeweisfÃ¼hrungen, oder zumindest Schlussfolgerungen, Ã¼ber die Korrektheit von Funktionen anzustellen. Dies fÃ¤ngt bereits bei den VorzÃ¼gen von unverÃ¤nderlichen gegenÃ¼ber verÃ¤nderlichen Datenstrukturen an - gerade bei NebenlÃ¤ufigkeit. Wenn Funktionen allerdings keine ZustÃ¤nde Ã¤ndern kÃ¶nnen, gelangt man spÃ¤testens bei IO-Operationen an den Punkt, dass irgendwie mit der Welt auÃŸerhalb des eigenen Programms interagiert werden muss. Dies geht auch in rein funktionalen Sprachen nur Ã¼ber Seiteneffekte - allerdings Seiteneffekte, die nur in eigenen Berechnungskontexten, abgeschottet vom Rest unseres Programms, auftreten dÃ¼rfen \cite[Kap. Input and Output]{Haskell11}.

Genau an dieser Stelle halten Konzepte wie Monaden aus der Mathematik (Kategorientheorie) in der Informatik Einzug. Der Weg zum VerstÃ¤ndnis von Monaden fÃ¼hrt Ã¼ber Funktoren und Applicatives, da aufgrund der Typklassenhierarchie eine Monade auch immer ein Applicative und ein Applicative ein Funktor ist. 

\section{Funktoren}
\begin{wrapfigure}[6]{r}{.52\textwidth}
	\begin{lstlisting}[aboveskip=-1em, language=purescript, caption=Typklasse Functor, label=FunctorTCPS]
	class Functor f where
		map :: forall a b. (a -> b) -> f a -> f b
	\end{lstlisting}
\end{wrapfigure}

Die Typklasse Funktor definiert eine Klasse fÃ¼r alle Typkonstruktoren \emph{f}, die eine map-Operation unterstÃ¼tzen - siehe Listing \ref{FunctorTCPS}. Die parametrisierten Typen Array oder Maybe sind bspw. Funktoren, da sie eine Instanz zur Typklasse Funktor definieren (dazu spÃ¤ter mehr) \cite[][S. 29, 33]{Freeman17}. Die Map-Funktion nimmt als erstes Argument eine Funktion von einem Typ \emph{a} in einen Typ \emph{b} an, als zweites einen Typ \emph{f} von \emph{a} und gibt einen Typ \emph{f} von \emph{b} zurÃ¼ck, indem sie die Funktion von \emph{a} nach \emph{b} auf den Typ \emph{f} von \emph{a} anwendet. Damit handelt es sich bei \emph{map} um eine Funktion hÃ¶herer Ordnung. 

Funktoren werden sich gerade in diesem Szenario oftmals als Container vorgestellt. Eine prÃ¤zisere Vorstellung wÃ¤re es sich einen Funktor als Berechnungskontext vorzustellen, in dem Seiteneffekte auftreten dÃ¼rfen \cite[Kap. Functors, Applicative Functors and Monoids, Abschn. Functors redux]{Haskell11}. Denn Ã¼ber den konkreten Berechnungskontext (Wertkonstruktor eines Funktors) entscheidet sich, was das Resultat einer Funktionsanwendung sein wird \cite{AdityaBhargava13}.

Bevor wir uns im Anschluss einem konkreten Beispiel mit Funktoren in PureScript und dessen Ãœbersetzung nach JavaScript widmen, soll im nÃ¤chsten Unterabschnitt das beschriebene Konzept zunÃ¤chst visualisiert werden.

\subsection{Funktoren in Bildern am Beispiel von Maybe}
Bei der Visualisierung des Funktorkonzepts wird sich des Algebraischen Datentyps \emph{Maybe} als Beispiel bedient. Listing \ref{MaybeFunktorPS} wiederholt noch einmal die Definition von \emph{Maybe} mit dessen Wertkonstruktoren \emph{Nothing} und \emph{Just}.

 \begin{wrapfigure}[9]{r}{.52\textwidth}
	\begin{lstlisting}[aboveskip=-1em, language=purescript, caption=ADT Maybe u. Funktorinstanz, label=MaybeFunktorPS]
	data Maybe a = Nothing | Just a
	
	instance functorMaybe :: Functor Maybe where
		map fn (Just x) = Just (fn x)
		map _  _        = Nothing
	\end{lstlisting}
\end{wrapfigure}

Um eine Funktion auf den Wert in einem Funktor anwenden zu kÃ¶nnen, ohne den Wert vorher auszupacken, bedarf es einer weiteren Funktion, in der definiert ist, wie die Funktionsanwendung durchgefÃ¼hrt werden soll - und das macht \emph{map}. 

\begin{wrapfigure}{r}{0.5\textwidth} % Inline image example
	\begin{center}
		\includegraphics[width=0.4\textwidth]{Pictures/context.png}
	\end{center}
	\caption{Maybe Context \cite[][]{AdityaBhargava13}}
	\label{fig:ContextMaybe}
\end{wrapfigure}

Anhand der Wertkonstruktoren, des Berechnungskontextes, wird entschieden, welche Auswirkungen die Anwendung einer Funktion hat. Abbildung \ref{fig:ContextMaybe} veranschaulicht dies. Je nachdem, ob ein \emph{Just} von etwas oder ein \emph{Nothing} vorliegt, muss die Anwendung einer Funktion, nennen wir sie \emph{fn}, unterschiedliche Auswirkungen haben (Seiteneffekt). In Listing \ref{MaybeFunktorPS} ist die Funktorinstanz von Maybe zur Typklasse Funktor aus Listing \ref{FunctorTCPS} aufgefÃ¼hrt.

Im Folgenden besprechen wir beide Definitionen von Map, je nachdem welches Pattern greift. Es beginnt mit dem Fall, dass Map eine Funktion \emph{fn} bekommt und ein \emph{Just} mit einem Wert \emph{x} eines Typen \emph{a}. Gehen wir zum besseren VerstÃ¤ndnis davon aus, der Typ wÃ¤re in einem konkreten Fall \emph{Int} und wir wÃ¼rden eine Funktion auf einen im Berechnungskontext gebundenen Wert \emph{2} anwenden wollen, die diesen mit einem freien Wert \emph{3} addiert (siehe Abbildung \ref{fig:MaybeJust}).

\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.75\textwidth]{Pictures/fmap-just.png}
	\caption{Funktionsanwendung auf ein Just von 2 \cite[][]{AdityaBhargava13}}
	\label{fig:MaybeJust}
\end{figure}

In dem Fall ist \emph{map} so definiert, dass intern die Funktion auf den Wert \emph{x = 2} angewendet wird. AnschlieÃŸend wird das Ergebnis, hier \emph{x = 5}, Ã¼ber den Wertkonstruktor \emph{Just} in einem neuen Berechnungskontext (Funktor) gekapselt und dieser zurÃ¼ckgegeben.

Wenn der andere Fall eintritt, dass \emph{map} eine Funktion bekommt und ein \emph{Nothing}, muss \emph{map} abweichend definiert sein. Denn auf was sollte die Funktion angewendet werden, wenn \emph{Nothing} ja gar keinen Wert intern bereithÃ¤lt.

\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.55\textwidth]{Pictures/fmap-nothing.png}
	\caption{Funktionsanwendung auf Nothing \cite[][]{AdityaBhargava13}}
	\label{fig:MaybeNothing}
\end{figure}

Wie in der Definition von \emph{map} in Listing \ref{MaybeFunktorPS} zu sehen und durch Abbildung \ref{fig:MaybeNothing} visualisiert, ist das vorgeschriebene Verhalten also, dass ohne Funktionsanwendung wieder ein \emph{Nothing} zurÃ¼ckgegeben wird.

Typinstanzen der Typklasse \emph{Functor} mÃ¼ssen darÃ¼ber hinaus zwei GesetzmÃ¤ÃŸigkeiten bei der Definition ihrer \emph{map}-Funktion einhalten:

\begin{itemize}
	\item Identity Law: \lstinline[language=purescript, columns=fixed]{map identity xs = xs}
	\item Composition Law: \lstinline[language=purescript, columns=fixed]{map g (map f xs) = map (g <<< f ) xs}
\end{itemize}

Diese Gesetze garantieren, dass nicht der Berechnungskontext (Funktor) verÃ¤ndert wird, sondern nur der Wert. Das Gesetz der IdentitÃ¤t sagt aus, dass wenn die IdentitÃ¤tsfunktion auf einen Funktor \emph{xs} angewendet wird, der originale Funktor zurÃ¼ckgegeben werden muss. Das macht Sinn, da die IdentitÃ¤tsfunktion ihre Eingabe nicht modifiziert. Das Gesetz der Komposition sagt aus, dass die Funktionsanwendung einer Funktion \emph{f} auf einen Funktor \emph{xs} Ã¼ber \emph{map} und die anschlieÃŸende Funktionsanwendung einer weiteren Funktion \emph{g} auf dieselbe Weise Ã¼ber den resultierenden Funktor, das gleiche Resultat erzeugen muss, wie wenn man die Komposition der beiden Funktion \emph{g} und \emph{f} direkt auf den Funktor Ã¼ber \emph{map} angewendet hÃ¤tte \cite[][S. 69]{AdityaBhargava13}. Der Infix-Operator \lstinline[language=purescript, columns=fixed]{<<<} beschreibt die Backwards-Komposition zweier Funktionen (\emph{g} nach \emph{f}) \cite[][S. 28]{Freeman17}.

\subsection{Funktoren in PureScript}
Dieser Unterabschnitt soll die Nutzung von Funktoren in PureScript an Beispielen verdeutlichen. Die Ãœbersetzung nach JavaScript der hier aufgefÃ¼hrten Beispiele wird im nÃ¤chsten Unterabschnitt aufgezeigt und besprochen.

ZunÃ¤chst greifen wir  in Listing \ref{FunctorExamplePS} die, durch Bilder illustrierten, Beispiele mit dem Funktor \emph{Maybe} des letzten Unterabschnitts auf. Die unÃ¤re Funktion wird jeweils auf ein \emph{Just} von 2 und auf ein \emph{Nothing} angewendet. Durch das in der Definition von \emph{map} verwendete Pattern Matching wird der Wert 2 aus dem Funktor geholt, die Funktion mit ihm als Argument aufgerufen und das Ergebnis dessen in einen neuen Funktor gesteckt. Bei \emph{Nothing} wird ohne Funktionsanwendung \emph{Nothing} zurÃ¼ckgegeben.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Beispiel mit Funktoren in PS, label=FunctorExamplePS]
module Main where

import Prelude
import Data.Maybe

x = map (\x -> x + 3) (Just 2) -- x = (Just 5)
y = map (\x -> x + 3) Nothing  -- y = Nothing
\end{lstlisting}

Arrays und auch Funktionen sind ebenfalls Funktoren. In Listing \ref{FunctorExample2PS} wird zunÃ¤chst eine unÃ¤re Funktion auf ein Array von Ganzzahlen angewendet. Wenn \emph{map} als Wert und Funktor eine Funktion bekommt, wirkt sich dies wie eine Funktionskomposition aus.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Weitere Funktoren in PS, label=FunctorExample2PS]
module Main where

import Prelude
import Data.Array

a = map (\x -> x + 1) [1, 2, 3, 4, 5] -- a = [2,3,4,5,6]
b = map (\x -> x + 3) (\x -> x + 2)   -- (b 1) = 6
\end{lstlisting}

Schauen wir uns zur Verdeutlichung der genauen Mechanik einmal die Implementierung der Typklasse Funktor im Falle der Instanzen fÃ¼r Arrays und Funktionen an. In Listing \ref{FunctorArrayFunctionPS} sind die Typinstanzen und die Implementierung der Funktion \emph{compose} angegeben. Diese wird in der RealitÃ¤t Ã¼ber mehrere Ebenen der Typklassenhierarchie geschliffen. Das soll an dieser Stelle aber nicht Gegenstand der Betrachtung sein. Die Implementierung der \emph{map}-Funktion fÃ¼r Arrays wird Ã¼ber einen Foreign Function Import aus JavaScript bereitgestellt (Listing \ref{FunctorArrayImplJS}).

\noindent\begin{minipage}[t]{.48\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=purescript, style=only-rect, caption= Typinstanzen fÃ¼r Arrays und Funktionen PS, label=FunctorArrayFunctionPS]
instance functorArray :: Functor 
	Array where
	map = arrayMap

instance functorFn :: Functor
	((->) r) where
	map = compose

-- imported over several modules
compose f g x = f (g x)	
	\end{lstlisting}
\end{minipage}% 
% 
\hfill% 
\begin{minipage}[t]{.50\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=javascript, style=only-rect, caption= Native JavaScript Impl., label=FunctorArrayImplJS] 
exports.arrayMap = function (f) {
	return function (arr) {
		var l = arr.length;
		var result = new Array(l);
		for (var i = 0; i < l; i++) {
			result[i] = f(arr[i]);
		}
		return result;
	};
};
	\end{lstlisting}
\end{minipage}
\hfill% 

BezÃ¼glich der Mechanik bei Arrays lÃ¤sst sich nun sagen, dass ein neues Array (Funktor) \emph{result} erzeugt wird, die Funktion \emph{f} auf jedes Element des alten Arrays (Funktors) \emph{arr} angewendet wird und das Resultat dieser Funktionsanwendung jeweils im neuen Funktor \emph{result} abgelegt wird. 

Die Mechanik bei Funktionen ist, wie es vom Verhalten der \emph{map}-Anwendung bereits zu vermuten war, die der Komposition von Funktionen, wie sie auch in anderen Sachverhalten eingesetzt wird. Es wird eine Funktion \emph{f} entgegen genommen, eine weitere Funktion \emph{g} als Funktor und eine neue Funktion (Funktor) zurÃ¼ckgegeben, in der zunÃ¤chst \emph{g} auf den Wert \emph{x} angewendet wird und anschlieÃŸend \emph{f} auf das Ergebnis davon. Das heiÃŸt in unserem konkreten Fall wird die Addition mit dem Wert 2 vor der Addition mit dem Wert 3 durchgefÃ¼hrt.

\subsection{Ãœbersetzung nach JavaScript}
Im Folgenden wird die Ãœbersetzung der Codebeispiele mit Funktoren des vorangegangenen Unterabschnitts dargestellt und erlÃ¤utert. In Listing \ref{FunctorExampleJS} ist die Ãœbersetzung von dem Maybe-Listing \ref{FunctorExamplePS} aufgefÃ¼hrt, in Listing \ref{FunctorExample2JS} die des Array- und Funktionen-Listings \ref{FunctorExample2PS}.

Da es sich bei \emph{Functor} um eine Typklasse handelt, ist das Ãœbersetzungsmuster gemÃ¤ÃŸ des in Abschnitt \glqq \ref{lbl:Typeclasses} \nameref{lbl:Typeclasses}\grqq{} beschriebenen. Es wird also analog die Typklasse \emph{Functor} aus PureScript als Object Type (Klasse) in JavaScript reprÃ¤sentiert. Die Typinstanz fÃ¼r den ADT \emph{Maybe} ist ein Objekt (Type Class Dictionary) mit der Bezeichnung \emph{functorMaybe}, welches die Implementierung der \emph{map}-Funktion fÃ¼r \emph{Maybe} definiert.  In dieser wird auf die Ãœbersetzung der Wertkonstruktoren \emph{Just a} und \emph{Nothing} des ADT \emph{Maybe} zurÃ¼ckgegriffen. Deren Ãœbersetzung gestaltet sich analog zur Ãœbersetzung der Werkkonstruktoren des Listen-ADT's aus Listing \ref{ADTJS} aus Abschnitt \glqq \ref{sec:ADT} \nameref{sec:ADT}\grqq{}. Zum besseren VerstÃ¤ndnis der Mechanik seien die zuvor genannten EntitÃ¤ten dennoch in Listing \ref{ADTMaybeFunctorJS} aufgefÃ¼hrt. Auf weiterfÃ¼hrende Beschreibungen wird allerdings verzichtet. Zur Reduzierung der LÃ¤nge des Listings sind an geeigneten Stellen ZeilenumbrÃ¼che entfernt worden.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung der Typklasse \emph{Functor} und Typinstanz \emph{functorMaybe}, label=ADTMaybeFunctorJS]
// ../Data.Functor/index.js
var Functor = function (map) { this.map = map; };

var map = function (dict) { return dict.map; };

// ../Data.Maybe/index.js
var functorMaybe = new Data_Functor.Functor(function (v) {
	return function (v1) { // v1 ist ein Objekt, v eine Funktion
		if (v1 instanceof Just) { return new Just(v(v1.value0)); };
		return Nothing.value;
	};
});

var Nothing = (function () { // kann oben als v1 auftreten 
	function Nothing() { };
	Nothing.value = new Nothing(); 
	return Nothing; 
})();

var Just = (function () { // kann oben als v1 auftreten 
	function Just(value0) { this.value0 = value0; };
	Just.create = function (value0) { return new Just(value0); };
	return Just; 
})();
\end{lstlisting}

Richten wir unser Augenmerk nun auf Listing \ref{FunctorExampleJS}. Es wird in Zeile 4 ein neues \emph{functorMaybe} Type Class Dictionary (Objekt in JavaScript, Typinstanz in PureScript) erzeugt. Dieses bekommt\footnote{aufgrund des Currying's wird auch in diesen und weiteren Beispielen partielle Anwendung in JavaScript genutzt, weshalb manche Formulierung unprÃ¤zise ist, aber es steht gerade anderes im Vordergrund} in diesem Fall eine unÃ¤re Additionsfunktion (oben \emph{v} genannt) und ein Objekt \emph{Just} (oben \emph{v1}) mit dem Wert 2 (oben \emph{v1.value0}). Das Type Class Dictionary \emph{functorMaybe} wird der freien Funktion \emph{map} des Moduls \emph{Data.Functor} als Argument Ã¼bergeben. Diese Funktion ruft anschlieÃŸend die Klassenfunktion \emph{map} auf, deren Implementierung die Ã¼bergebene Additionsfunktion und das Funktorobjekt entsprechend des bereits zuvor beschriebenen Mechanismuses des Maybe-Funktors verwertet (Zeile 9, Listing \ref{ADTMaybeFunctorJS}). Der Fall mit dem Wertkonstruktor \emph{Nothing} in Zeile 10 bis 12 aus Listing \ref{FunctorExampleJS} ist im Aufrufverhalten gleich, wird aber unterschiedlich verwertet (Zeile 10, Listing \ref{ADTMaybeFunctorJS}).

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung des Maybe-Funktorenbeispiels nach JS, label=FunctorExampleJS]
var Data_Functor = require("../Data.Functor");
var Data_Maybe = require("../Data.Maybe");
var Data_Semiring = require("../Data.Semiring");
var Prelude = require("../Prelude");

var x = Data_Functor.map(Data_Maybe.functorMaybe)(function (x1) {
	return x1 + 3 | 0;
})(new Data_Maybe.Just(2));

var y = Data_Functor.map(Data_Maybe.functorMaybe)(function (x1) {
	return x1 + 3 | 0;
})(Data_Maybe.Nothing.value);
\end{lstlisting}

 \begin{wrapfigure}[10]{r}{.52\textwidth}
	\begin{lstlisting}[aboveskip=-1em, language=javascript, caption=Auszug Funktor Array u. Function, label=ArrayFunctionFunctorJS]
var functorArray = new Functor($foreign.arrayMap);

var compose = function (f) {
	return function (g) {
		return function (x) {
			return f(g(x)); }; }; });	
	\end{lstlisting}
\end{wrapfigure}

Kommen wir nun zur Ãœbersetzung von Arrays und Funktionen als Funktoren in Listing \ref{FunctorExample2JS}. Da Arrays ein in die Sprache PureScript direkt eingebauter Datentyp sind, ist das Aufrufverhalten einfacher als bei \emph{Maybe}. Das Type Class Dictionary \emph{functorArray} bekommt ohne Umschweife bei Erzeugung aus der Funktorklasse die Implementierung von \emph{arrayMap} (Listing \ref{FunctorArrayImplJS}) Ã¼bergeben. Da die exakte Umsetzung des Funktors \emph{functorFn}, wie bereits zuvor erwÃ¤hnt, weitere Typklassen einfÃ¼hren wÃ¼rde, sei auch an dieser Stelle in Listing \ref{ArrayFunctionFunctorJS} nur die Implementierung in JavaScript der \emph{compose}-Funktion angeben. Das Aufrufverhalten gestaltet sich jedoch wieder analog zu dem von \emph{Maybe}.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung des Beispiels mit Array und Funktion als Funktor nach JS, label=FunctorExample2JS]
var a = Data_Functor.map(Data_Functor.functorArray)(function (x) {
	return x + 1 | 0;
})([ 1, 2, 3, 4, 5 ]);

var b = Data_Functor.map(Data_Functor.functorFn)(function (x) {
	return x + 3 | 0;
})(function (x) {
	return x + 2 | 0;
});
\end{lstlisting}

\section{Applicatives}
Applicatives sind eine Subklasse von Funktoren und erweitern diese um zwei weitere Funktionen.
\begin{itemize}
	\item apply - wie map, nur, dass auch die Funktion, die angewendet werden soll, bereits in einem Funktor steckt \cite[][S. 84]{Freeman17}
	\item pure - um Werte in einen Funktor zu betten, in einen Berechnungskontext zu heben \cite[][S. 86]{Freeman17}
\end{itemize}
In PureScript steht die Typklasse \emph{Applicative} nicht direkt unter \emph{Functor} in der Hierarchie, sondern \emph{Functor} wird zunÃ¤chst durch eine Typklasse names \emph{Apply} erweitert und diese anschlieÃŸend von \emph{Applicative}. In Listing \ref{ApplicativeTCPS} wird dies dargestellt und auf welcher Hierarchieebene welche der beiden Funktionen wie definiert ist.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Typklasse Applicative, label=ApplicativeTCPS]
class Functor f where
	map :: forall a b. (a -> b) -> f a -> f b

class Functor f <= Apply f where
	apply :: forall a b. f (a -> b) -> f a -> f b

class Apply f <= Applicative f where
	pure :: forall a. a -> f a
\end{lstlisting}

Bevor wir uns im Anschluss einem konkreten Beispiel mit Applicatives in PureScript und dessen Ãœbersetzung nach JavaScript widmen, soll im nÃ¤chsten Unterabschnitt das beschriebene Konzept zunÃ¤chst visualisiert werden.

\subsection{Applicatives in Bildern am Beispiel von Maybe}
Bei der Visualisierung des Konzepts von Applicatives wird sich, wie zuvor bei Funktoren, des Algebraischen Datentyps \emph{Maybe} als Beispiel bedient. In Listing \ref{MaybeApplicativePS} ist die Typinstanz fÃ¼r \emph{Maybe} als Funktor nochmals wiederholt und die neuen Typinstanzen fÃ¼r die Typklassen \emph{Apply} und \emph{Applicative} aufgefÃ¼hrt.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Applicative-Intanz Maybe, label=MaybeApplicativePS]
instance functorMaybe :: Functor Maybe where
	map fn (Just x) = Just (fn x)
	map _  _        = Nothing

instance applyMaybe :: Apply Maybe where
	apply (Just fn) x = fn <$> x
	apply Nothing   _ = Nothing
	
instance applicativeMaybe :: Applicative Maybe where
	pure = Just
\end{lstlisting}

An der Definition der Typinstanz \emph{applyMaybe} ist zu sehen, dass die Funktion \emph{apply} ihr erstes Argument in einem Funktor haben mÃ¶chte. Das ist der Unterschied zur Funktion \emph{map} bei Funktoren. Durch Abbildung \ref{fig:MaybeApplicativeJust} wird das Vorgehen visualisiert dargestellt. FÃ¼r den Fall, dass das erste Argument eine Funktion in einem \emph{Just} ist und das zweite Argument ein Wert in einem Funktor, werden beide durch das Pattern Matching ausgepackt. AnschlieÃŸend wird die Funktion durch \emph{map}, vertreten durch seinen Infix-Alias \emph{<\$>}, auf den Wert angewendet und das Resultat wieder in einen Funktor eingebettet \cite[][S. 84]{Freeman17}.

\begin{figure}[htb!]
	\centering
	\includegraphics[width=0.75\textwidth]{Pictures/applicative-just.png}
	\caption{Funktionsanwendung aus einem Just auf ein Just von 2 \cite[][]{AdityaBhargava13}}
	\label{fig:MaybeApplicativeJust}
\end{figure}

FÃ¼r den Fall, dass das erste Argument ein \emph{Nothing} ist, wird, wie bei Funktoren auch, wieder ein \emph{Nothing} zurÃ¼ckgeliefert. Bei Funktoren gab es keinen Wert, auf den die Funktion \emph{fn} hÃ¤tte angewendet werden kÃ¶nnen. Jetzt gibt es keine Funktion \emph{fn}, da das erste Argument ein \emph{Nothing} ist und den Wert ohne Funktionsanwendung einfach wieder zurÃ¼ckzugeben, wÃ¼rde zu einem Typfehler fÃ¼hren. Denn das zweite Argument ist vom Typ \emph{a} bevor es durch eine Funktion von \emph{a} nach \emph{b} zu einem Typ von \emph{b} wird. Ohne diese Funktion zu haben, bleibt uns keine andere Option als Nothing zu erzeugen.

In der Typinstanz \emph{applicativeMaybe} wird die konstante Funktion \emph{pure} fÃ¼r \emph{Maybe} definiert, indem sie den Wertkonstruktor \emph{Just} zugewiesen bekommt.

Die Typinstanzen der Typklasse \emph{Applicative} bzw. \emph{Apply} mÃ¼ssen bei der Implementierung der Funktionsdeklarationen ebenso wie Funktoren einige Gesetze einhalten. Diese sollen an dieser Stelle aber nicht im Detail besprochen werden.

\subsection{Applicatives in PureScript}
Dieser Unterabschnitt soll die Nutzung von Applicatives und vor allem ihre VorzÃ¼ge im Vergleich zu Funktoren an Beispielen verdeutlichen. Die Ãœbersetzung nach JavaScript der hier aufgefÃ¼hrten Beispiele wird im nÃ¤chsten Unterabschnitt besprochen.

In Listing \ref{ApplicativeExamplePS} ist der bereits erwÃ¤hnte Unterschied zu Funktoren demonstriert. Dort wird neben der Funktion \emph{apply} auch deren Infix-Alias \emph{<*>} genutzt. Im Gegensatz zu \emph{map} dÃ¼rfen sich die Funktionen ebenfalls bereits in einem Funktor befinden.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Beispiel mit Applicatives in PS, label=ApplicativeExamplePS]
module Main where

import Prelude
import Data.Maybe

a = apply (Just \x -> x + 3) (Just 2) 			  	 -- (Just 5)
b = [(\x -> x * 2), (\x -> x + 2)] <*> [1, 2, 3] -- [2,4,6,3,4,5]
c = [(\x y -> x * y), (\x y -> x + y)] <*> pure 2  <*> [1, 2, 3]
\end{lstlisting}

Zeile 6 zeigt, dass \emph{apply} im Grunde wie \emph{map} funktioniert, wie wir auch schon anhand ihrer Definition erkennen konnten. Das Beispiel ist im Resultat Ã¤quivalent mit dem in Listing \ref{FunctorExamplePS} bei Funktoren. Dadurch, dass die Funktion in einem Funktor sein darf, erÃ¶ffnen sich aber auch MÃ¶glichkeiten, welche die MÃ¤chtigkeit von einfachen Funktoren Ã¼bersteigen. Ein erstes Beispiel dafÃ¼r ist in Zeile 7 zu sehen. Ein Array ist ebenso ein Funktor und kann damit, gefÃ¼llt mit Funktionen, genutzt werden. Als Auswirkung wird zunÃ¤chst die erste Funktion auf die Elemente des Arrays, dass als Wert gedient hat, angewendet und im Anschluss die zweite Funktion auf dieselben Ursprungswerte. Als Ergebnis entsteht ein Array, dass die Resultate der beiden Funktionsanwendungen in sich vereint. 

In Zeile 7 wird kurz die praktische Nutzung von \emph{pure} demonstriert, was einen einfachen Wert in den Berechnungskontext hebt. Die vorherigen unÃ¤ren Funktionen sind jetzt binÃ¤r, damit der Wert 2 und jeweils ein Element des Arrays wie zuvor in Zeile 6 miteinander verrechnet werden kÃ¶nnen. Es entsteht demnach das gleiche Array als Ergebnis.

Es deutete sich bereits an, dass die praktische Ausnutzung des Unterschieds von Funktoren zu Applicatives etwas mit der Anzahl der Argumente einer Funktion zu tun haben kÃ¶nnte. Dies soll nachfolgend, durch Listing \ref{ApplicativeExample2PS} begleitet, bestÃ¤tigt werden.

Wenn wir bei Funktoren eine unÃ¤re Funktion auf einen Wert in einem Berechnungskontext anwenden, erhalten wir einen Wert in einem neuen Berechnungskontext (Zeile 1). Wird allerdings mindestens eine binÃ¤re Funktion angewendet, ergibt dies durch die partielle Anwendung eine Funktion, die um ein Argument kÃ¼rzer ist (Zeile 2). Dies ist kein wirklicher Unterschied zu Zeile 1, denn dort wurde durch die partielle Anwendung eine Funktion von einem Argument auf eine Funktion von keinem Argument reduziert, also auf eine konstante Funktion bzw. Wert. In beiden FÃ¤llen haben wir prinzipiell das Problem: \glqq Und wie solls jetzt \textbf{weitergehen}?\grqq{}. Entweder wir legen selbst Hand an und holen unseren Wert oder Funktion aus dem Berechnungskontext durch Pattern Matching heraus, verwerten ihn und heben ihn wieder in einen neuen Kontext hoch (Zeile 4 - 6) oder wir bedienen uns etwas Vorgefertigtem. 

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Grenzen von Funktoren, label=ApplicativeExample2PS]
a = (\x -> x + 3) <$> (Just 2)   -- a = (Just 5)
b = (\x y -> x + y) <$> (Just 2) -- b = (\y -> 2 + y)

c :: Maybe (Int -> Int) -> Int -> Maybe Int -- (c b 3) = (Just 5)
c (Just f) y = Just(f y)
c Nothing y = Nothing

d = lift2 (\x y -> x + y) (Just 2) (Just 3) -- d = (Just 5)
\end{lstlisting}

In Zeile 8 wird durch die Funktion \emph{lift2} aus dem Modul \emph{Control.Apply} eine Funktion, die zwei Argumente annimmt, mit diesen Argumenten in einen Berechnungskontext gehoben, die Funktion auf diese angewendet und das Resultat in einen neuen Berechnungskontext gepackt. SchÃ¶n und gut, aber was ist, wenn die Funktion drei Argumente annimmt?  In diesem Modul gibt es Lift-Funktionen fÃ¼r Funktionen bis zu fÃ¼nf Argumenten, aber etwas umstÃ¤ndlich ist es dennoch noch und wir sind nicht in der Lage Funktionen mit einer beliebigen Anzahl Argumente zu behandeln. 

Schauen wir uns in Listung \ref{ApplicativeExample3PS} exemplarisch an, wie die Lift-Funktionen definiert sind. Es fÃ¤llt auf, dass die Definition einem strikten Schema folgen, was wir statisch unendlich so weiterfÃ¼hren kÃ¶nnten. Alternativ kÃ¶nnten wir uns aber auch eine Funktion \emph{lift1} definieren und diese durch mehrfache partielle Anwendung auf Funktionen einer beliebigen Anzahl Argumente anwenden - solange wie es fÃ¼r einen spezifischen Anwendungsfall von NÃ¶ten ist.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Auszug aus \emph{Control.Apply}, label=ApplicativeExample3PS]
lift2 :: forall a b c f. Apply f => (a -> b -> c) -> f a -> f b -> f c
lift2 f a b = f <$> a <*> b

lift3 :: forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
lift3 f a b c = f <$> a <*> b <*> c
\end{lstlisting}

Die Funktion \emph{lift1} gibt es bereits und nennt sich \emph{apply}. Sie ist neben der Funktion \emph{pure}, die wenn man so will Funktionen mit keinen Argumenten in einen Berechnungskontext hochhebt, das was die Typklasse \emph{Applicative} ausmacht und alles was wir brauchen. 

Listing \ref{ApplicativeExample4PS} zeigt zur Verdeutlichung nochmal die Funktionsdeklaration von \emph{apply} und anhand der Beispiele aus Listing \ref{ApplicativeExample2PS} wie sie sich bequem deklarativ, ohne Boilerplate-Code, durch Applicatives formulieren lassen.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Aneinanderkettung von Berechnungen mit Applicatives in PS, label=ApplicativeExample4PS]
-- apply :: forall a b. f (a -> b) -> f a -> f b

a = (\x y -> x + y) <$> (Just 2) <*> (Just 3) -- a = (Just 5)
b = (\x y z -> x + y + z) <$> (Just 2) <*> (Just 3) <*> (Just 5) 
-- b = (Just 10)
\end{lstlisting}

Applicatives sind also einfachen Funktoren bei Funktionen mit mehr als einem Argument Ã¼berlegen. Durch die Kombination von \emph{map} und \emph{apply} kÃ¶nnen Funktionen mit beliebiger Anzahl ungebundener Argumente auf die gleiche Anzahl von Werten, die bereits in einem Berechnungskontext gebunden sind, angewendet werden. Das Ergebnis der sukzessive partiellen Funktionsanwendung ist wie bei Funktoren ein Wert in einem neuen Berechnungskontext. So scheint es kein Zufall zu sein, dass Funktoren in dem Modul \emph{Data} definiert sind und Applicatives im Modul \emph{Control}, da sie zusÃ¤tzlich doch eine generische Art und Weise vorgeben, wie herkÃ¶mmliche Funktionen elegant mit eingepackten Werten umgehen kÃ¶nnen. Sie erlauben im Gegensatz zu einfachen Funktoren eine Aneinanderreihung von Berechnungsschritten unter dem Standpunkt der funktionalen Sicht auf Seiteneffekte.

\subsection{Ãœbersetzung nach JavaScript}
In diesem Unterabschnitt  wird die Ãœbersetzung einiger Codebeispiele mit Applicatives des vorangegangenen Unterabschnitts dargestellt und erlÃ¤utert. Diese sind in Listing \ref{ApplicativeSummaryPS} nochmal zusammengefasst aufgefÃ¼hrt.

Da es sich bei Applicatives um eine Typklasse handelt, ist das Ãœbersetzungsmuster gemÃ¤ÃŸ des in Abschnitt \glqq \ref{lbl:Typeclasses} \nameref{lbl:Typeclasses}\grqq{} beschriebenen. Es wird also analog die Typklasse \emph{Applicative} aus PureScript als Object Type (Klasse) in JavaScript reprÃ¤sentiert. Die Typinstanz fÃ¼r den ADT \emph{Maybe} ist ein Objekt (Type Class Dictionary) mit der Bezeichnung \emph{applicativeMaybe}.  Da in der Ãœbersetzung auf die Wertkonstruktoren \emph{Just a} und \emph{Nothing} des ADT \emph{Maybe} und auf die von Funktoren zurÃ¼ckgegriffen wird, lohnt ein Blick in Listing \ref{ADTMaybeFunctorJS}. Applicatives stehen in der Typklassenhierarchie unter \emph{Apply} und \emph{Functor}. Diese Beziehung wird Ã¼ber die Ãœbersetzung ebenfalls deutlich. Zur Reduzierung der LÃ¤nge der nachfolgenden Listings sind an geeigneten Stellen ZeilenumbrÃ¼che entfernt worden.

In Listing \ref{TypeClassApplicativeJS} ist die Ãœbersetzung der Typklassen \emph{Apply} und \emph{Applicative} nach JavaScript dargestellt. In \emph{Apply} wird dazu auf die Ãœbersetzung der Typklasse \emph{Functor} zurÃ¼ckgegriffen und in \emph{Applicative} auf die von \emph{Apply}. An dieser Stelle wird also die Beziehung zwischen diesen Typklassen deutlich und auch, dass ein Applicative auch immer ein Funktor ist, da es Ã¼ber die gleichen FÃ¤higkeiten verfÃ¼gt.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung der Typklassen \emph{Apply} und \emph{Applicative}, label=TypeClassApplicativeJS]
// ../Control.Apply/index.js
var Apply = function (Functor0, apply) {
	this.Functor0 = Functor0;
	this.apply = apply;
};
var apply = function (dict) { return dict.apply; };

// ../Control.Applicative/index.js
var Applicative = function (Apply0, pure) {
	this.Apply0 = Apply0;
	this.pure = pure;
};
var pure = function (dict) { return dict.pure; };
\end{lstlisting}

Listing \ref{ADTMaybeApplicativeJS} zeigt, analog zu Funktoren in Listing \ref{ADTMaybeFunctorJS}, die Typinstanzen fÃ¼r \emph{Apply} und \emph{Applicative} im Falle des ADT's \emph{Maybe}.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung der Typinstanzen fÃ¼r \emph{Maybe}, label=ADTMaybeApplicativeJS]
// ../Data.Maybe/index.js
var applyMaybe = new Control_Apply.Apply(
	function () { return functorMaybe; }, function (v) {
	return function (v1) { // v1 ist ein Objekt, v eine Funktion, ..
		if (v instanceof Just) { // nun auch in einem Objekt gekapselt
			return Data_Functor.map(functorMaybe)(v.value0)(v1);
		};
		if (v instanceof Nothing) {
			return Nothing.value;
		};
		throw new Error("<pattern error message skipped by author>");
	};
});

var applicativeMaybe = new Control_Applicative.Applicative(
	function () { return applyMaybe; }, Just.create);
\end{lstlisting}

Das Vorgehen unterscheidet sich nicht wesentlich von dem, welches wir bei Funktoren vorgefunden haben. Wegen der Typklassenhierarchie wird auch hier wieder auf die Typinstanzen des Ã¼bergeordneten Typs zugegriffen. Die Funktion \emph{pure} wird zu einer Erstellung von einem \emph{Just} (Zeile 16). Die Funktion \emph{apply} ist, im Falle eines \emph{Just}, Ã¼ber den Aufruf der Funktion \emph{map} von Funktoren definiert, indem es dieser die ausgepackte Funktion (\emph{v.value0}) und den noch eingepackten Wert (\emph{v1}) Ã¼bergibt. Im Fall von \emph{Nothing} passiert das gleiche wie bei Funktoren. Da es fÃ¼r einen anderen Fall kein definiertes Verhalten gibt, wird in einem solchen ein Fehler geworfen.

Die Ãœbersetzung der in Listing \ref{ApplicativeSummaryPS} zusammengefassten Codebeispiele werden im Folgenden nacheinander besprochen. Es werden nur fÃ¼r das VerstÃ¤ndnis nÃ¶tige Imports einmalig beim ersten Listing aufgefÃ¼hrt.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Applicatives in PS, label=ApplicativeSummaryPS]
a = [(\x -> x * 2), (\x -> x + 3)] <*> [1, 2, 3]
b = (\x y -> x + y) <$> (Just 2) <*> (Just 3)
c = (\x y z -> x + y + z) <$> (Just 2) <*> (Just 3) <*> (Just 5)
\end{lstlisting}

\begin{wrapfigure}[16]{r}{.55\textwidth}
 \begin{lstlisting}[aboveskip=-1em, language=javascript, caption=Auszug Control.Apply, label=ArrayFunctionApplicativeJS]
exports.arrayApply = function (fs) {
	return function (xs) {
		var l = fs.length;
		var k = xs.length;
		var result = new Array(l*k);
		var n = 0;
		for (var i = 0; i < l; i++) {
			var f = fs[i];
			for (var j = 0; j < k; j++) {
				result[n++] = f(xs[j]);
			}
		}
		return result;
	};
};
\end{lstlisting}
\end{wrapfigure}

Die Ãœbersetzung des Beispiels unter Verwendung von Arrays ist in Listing \ref{ApplicativeExample1JS} dargestellt. Wie bereits im Abschnitt Ã¼ber Funktoren erwÃ¤hnt, ist das Aufrufverhalten beim fest in die Sprache eingebauten Typ \emph{Array} einfacher als bei Typen wie \emph{Maybe}. Analog wie in Listing \ref{ArrayFunctionFunctorJS} bereits dargestellt, bekommt das Type Class Dictionary \emph{applyArray} bei Erzeugung aus der Applyklasse direkt die Implementierung von \emph{arrayApply}  Ã¼bergeben. Diese ist in Listing \ref{ArrayFunctionApplicativeJS} aufgefÃ¼hrt.

Das Beispiel soll verdeutlichen wie ein einfacher Aufruf von \emph{apply} realisiert wird. In Zeile 7 wird ein neues  \emph{applyArray} Type Class Dictionary (Objekt) erzeugt. Dieses hÃ¤lt die beiden, zuvor in einem Array abgelegten, Funktionen. DarÃ¼ber hinaus bekommt es das Array von drei Werten Ã¼bergeben. Das Type Class Dictionary wird der freien Funktion \emph{apply} des Moduls \emph{Control.Apply} als Argument Ã¼berreicht. Diese Funktion ruft anschlieÃŸend die Klassenfunktion \emph{apply} auf, was zum Aufruf von \emph{arrayApply} aus Listing \ref{ArrayFunctionApplicativeJS} fÃ¼hrt.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung von Applicatives mit Arrays nach JS, label=ApplicativeExample1JS]
var Control_Apply = require("../Control.Apply");
var Data_Functor = require("../Data.Functor");
var Data_Maybe = require("../Data.Maybe");

var a = Control_Apply.apply(Control_Apply.applyArray)
([ function (x) {
	return x * 2 | 0;
}, function (x) {
	return x + 3 | 0;
} ])([ 1, 2, 3 ]);
\end{lstlisting}

In der Funktion \emph{arrayApply} wird das Array von Funktionen \emph{fs} und das Array von Werten \emph{xs} angenommen. In einer ersten Schleife wird sich die jeweilige Funktion herausgenommen. In einer zweiten geschachtelten Schleife wird diese Funktion auf alle Argumente angewendet und die Resultate in einem neuen Array gespeichert. Darauf folgt die Anwendung aller weiteren Funktionen auf dieselbe Weise.

Im nachfolgenden Listing \ref{ApplicativeExample2JS} soll verdeutlicht werden, wie ein Aufruf von \emph{map} in Verbindung mit einem Aufruf von \emph{apply} Ã¼bersetzt wird.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung von Applicatives mit Maybe nach JS, label=ApplicativeExample2JS]
var b = Control_Apply.apply(Data_Maybe.applyMaybe)
(Data_Functor.map(Data_Maybe.functorMaybe)
(function (x) {
	return function (y) {
		return x + y | 0;
	};
})(new Data_Maybe.Just(2)))(new Data_Maybe.Just(3));
\end{lstlisting}

Die \emph{map}-Funktion bekommt das \emph{Just} von 2 und dieses wird an den Parameter \emph{x} gebunden. Im Anschluss bekommt die \emph{apply}-Funktion die in einem \emph{Just} gekapselte partiell aufgerufene Funktion des \emph{map}-Aufrufs sowie das \emph{Just} von 3 und ersetzt den Parameter \emph{y} mit diesem.

Bei weiteren \emph{apply}-Aufrufen wird, wie in Listing \ref{ApplicativeExample3JS} zu sehen, ein weiteres \emph{applyMaybe} Objekt nach dem gleichen Schema in den Aufruf integriert.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung von Applicatives mit Maybe nach JS, label=ApplicativeExample3JS]
var c = Control_Apply.apply(Data_Maybe.applyMaybe)
(Control_Apply.apply(Data_Maybe.applyMaybe)
(Data_Functor.map(Data_Maybe.functorMaybe)
(function (x) {
	return function (y) {
		return function (z) {
			return (x + y | 0) + z | 0;
		};
	};
})(new Data_Maybe.Just(2)))(new Data_Maybe.Just(3)))(new Data_Maybe.Just(5));
\end{lstlisting}

\section{Monaden}
Monaden sind eine Subklasse von Applicatives und erweitern diese um eine Funktion \emph{bind}. Kurz zur Wiederholung und zur Intention von \emph{bind}:
\begin{itemize}
	\item Funktoren erlauben es durch \emph{map}, eine Funktion auf einen Wert in einem Funktor anzuwenden.
	\item Applicatives erlauben es durch \emph{apply}, eine Funktion in einem Funktor auf einen Wert in einem Funktor anzuwenden. Dadurch wird die Aneinanderreihung von Funktionsberechnungen mÃ¶glich.
	\item Monaden erlauben es durch \emph{bind}, eine Funktion entgegen zu nehmen, die einen kontextlosen Wert nimmt und einen Wert in einem Kontext (Monade) zurÃ¼ckliefert. Die anzuwendende Funktion darf also im Gegensatz zu \emph{map} oder \emph{apply} bereits einen eingepackten Wert zurÃ¼ckliefern. Dadurch wird die Aneinanderreihung von Funktionsberechnungen ermÃ¶glicht, wo in jeweils jeder Funktionsberechnung entschieden werden kann, welche Berechnung auf der Basis des Ergebnisses der vorangegangen Berechnung ausgefÃ¼hrt werden soll. Der resultierende spezifische Berechnungskontext hÃ¤ngt also lediglich von der Auswertung der Funktion ab, nicht von der Definition des Pattern Matchings des Funktors (siehe bspw. Listing \ref{MaybeMonadPS}).
\end{itemize}

In PureScript gibt es auf der gleichen Hierarchieebene wo sich sich die Typklasse \emph{Applicative} befindet eine Typklasse \emph{Bind}, welche die Funktion \emph{bind} deklariert. Die Typklasse Monad erweitert eine Ebene darunter diese beiden Typklassen und bringt deren FunktionalitÃ¤t damit zusammen, wie in Listing \ref{MonadTCPS} zu sehen \cite[][S. 101]{Freeman17}. In der Bibliothek wird im Zusammenhang mit Monaden der Funktor in deren Funktionsdeklaration mit dem Buchstaben \emph{m} anstatt \emph{f} ausgedrÃ¼ckt, was aber keinen Unterschied macht.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Typklasse Monad, label=MonadTCPS]
class Functor f where
	map :: forall a b. (a -> b) -> f a -> f b

class Functor f <= Apply f where
	apply :: forall a b. f (a -> b) -> f a -> f b

class Apply f <= Applicative f where
	pure :: forall a. a -> f a

class Apply m <= Bind m where
	bind :: forall a b. m a -> (a -> m b) -> m b

class (Applicative m, Bind m) <= Monad m
\end{lstlisting}

Bevor wir uns im Anschluss einem konkreten Beispiel mit Monaden in PureScript und dessen Ãœbersetzung nach JavaScript widmen, soll im nÃ¤chsten Unterabschnitt das beschriebene Konzept zunÃ¤chst visualisiert werden.

\subsection{Monaden in Bildern am Beispiel von Maybe}
Bei der Visualisierung des Konzepts von Monaden wird sich, wie zuvor bei Funktoren und Applicatives, des Algebraischen Datentyps \emph{Maybe} als Beispiel bedient. In Listing \ref{MaybeMonadPS} ist die Typinstanz fÃ¼r \emph{Maybe} als Funktor und Applicative nochmals wiederholt und die neuen Typinstanzen fÃ¼r die Typklassen \emph{Bind} und \emph{Monad} aufgefÃ¼hrt.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Monad-Instanz Maybe, label=MaybeMonadPS]
instance functorMaybe :: Functor Maybe where
	map fn (Just x) = Just (fn x)
	map _  _        = Nothing

instance applyMaybe :: Apply Maybe where
	apply (Just fn) x = fn <$> x
	apply Nothing   _ = Nothing

instance applicativeMaybe :: Applicative Maybe where
	pure = Just

instance bindMaybe :: Bind Maybe where
	bind (Just x) k = k x
	bind Nothing  _ = Nothing
	
instance monadMaybe :: Monad Maybe
\end{lstlisting}

An der Typinstanz \emph{bindMaybe} ist zu sehen, dass wir einen Wert in dem Monadentyp \emph{Just} oder \emph{Nothing} erwarten. Durch Abbildung \ref{fig:MaybeMonadJust} wird das Vorgehen fÃ¼r den ersten Fall visualisiert dargestellt. Die Funktion \emph{bind} bekommt einen Wert in einer Monade (Funktor) als erstes Argument. Durch Pattern Matching wird der Wert ausgepackt. Das zweite Argument ist eine beliebige Funktion, die einen Wert auÃŸerhalb eines Funktors erwartet und einen Wert in einem Funktor zurÃ¼ckliefert. Der RÃ¼ckgabewert der Funktionsanwendung ist gleichzeitig der RÃ¼ckgabewert von \emph{bind}.

Das bedeutet die Funktion, die als Argument angeben wird, entscheidet \textbf{wie} es \textbf{weitergeht} - was fÃ¼r ein Funktor genau zurÃ¼ckgegeben wird. Bei den Funktionen \emph{map} und \emph{apply} war das durch deren Fallunterscheidung bereits entschieden. FÃ¼r den Fall von \emph{Maybe} in Listing \ref{MaybeMonadPS} ist in Zeile 13 nicht entschieden, dass wenn wir ein \emph{Just} von etwas bekommen auch wie bei \emph{map} und \emph{apply} ein \emph{Just} resultieren muss (Zeile 2 und 6). Die Funktion \emph{k} kÃ¶nnte auch ein \emph{Nothing} zurÃ¼ckliefern. In Abbildung \ref{fig:MaybeMonadJust} ist bspw. eine Funktion \emph{half} definiert, wie in Listing \ref{HalfPS} dargestellt.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Funktion mit Monad-Anwendung, label=HalfPS]
half :: Int -> Maybe Int
half x = if even x
	then Just (div x 2)
	else Nothing

retNothing = Just 20 >>= half >>= half >>= half
\end{lstlisting}

\begin{wrapfigure}[20]{r}{.55\textwidth}
	\centering
	\includegraphics[width=0.4\textwidth]{Pictures/monad-just.png}
	\caption{Funktionsanwendung auf ein Just von 3, wo der Ausgang der Funktionsanwendung, die RÃ¼ckgabe von \emph{bind} bestimmt \cite[][]{AdityaBhargava13}}
	\label{fig:MaybeMonadJust}
\end{wrapfigure}

Durch \emph{half} entscheidet sich, ob der Aufruf von \emph{bind} ein \emph{Just} oder ein \emph{Nothing} zurÃ¼ckliefern wird. Wie in Zeile 6 des Listings zu sehen, kann man dadurch eine direkte Verkettung von \emph{bind}-Aufrufen angeben. Die Funktion \emph{bind} wird dort durch deren Infix-Alias \emph{>>=} vertreten \cite[][S. 101]{Freeman17}. Aus dem ersten Aufruf resultiert ein \emph{Just 10}, wird im zweiten Aufruf von \emph{bind} ausgepackt und erneut in die Funktion \emph{half} gesteckt. Das Resultat davon ist \emph{Just 5}, was bei, dritten Aufruf von \emph{bind} in einem \emph{Nothing} endet. Alle erneuten Anwendungen wÃ¼rden immer in einem \emph{Nothing} enden, da die Funktion \emph{half} per Typinstanzdefinition nicht mehr angewendet, sondern gleich \emph{Nothing} zurÃ¼ckgegeben wird.

Das bedeutet, wÃ¤hrend in der Aneinanderreihung von Berechnungen bei Applicatives die Ausgangsfunktion statisch war und der Fokus eher auf sich verÃ¤ndernden Werten lag (Listing \ref{ApplicativeExample4PS}), stehen bei Monaden sich potenziell verÃ¤ndernde Funktionsangaben im Vordergrund. Der Ausgangswert ist hier statisch und die resultierenden Werte sind von den angegebenen Funktionen abhÃ¤ngig. In Listing \ref{HalfPS} Zeile 6 kÃ¶nnte bspw. auch eine andere Funktion des gleichen Funktortyps an die Stelle eines oder mehrerer \emph{half}-Angaben treten.

Die Typinstanzen der Typklasse \emph{Monad} bzw. \emph{Bind} mÃ¼ssen bei der Implementierung der Funktionsdeklarationen ebenso wie Funktoren und Applicatives einige Gesetze einhalten. Diese werden im NÃ¤chsten Unterabschnitt mit der EinfÃ¼hrung der Do-Notation besprochen.

\subsection{Monaden in PureScript}
Dieser Unterabschnitt soll die Nutzung von Monaden in PureScript an einem Beispiel verdeutlichen. Dessen Ãœbersetzung nach JavaScript wird im nÃ¤chsten Unterabschnitt besprochen.

In Listing \ref{Half2PS} ist das Beispiel mit Monaden des vorherigen Unterabschnitts aus Listing \ref{HalfPS} etwas angepasst. Anstatt, dass beim dritten Aufruf der Funktion \emph{half} ein Nothing resultiert, sorgt der zwischengeschobene Aufruf der Funktion \emph{decIfOdd} dafÃ¼r, dass ein \emph{Just 2} als Ergebnis berechnet werden kann. Anstatt explizit \emph{Just 20} wie zuvor zu verwenden, wird an dieser Stelle der Wert 20 Ã¼ber \emph{pure} in den Berechnungskontext gehoben.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Funktionen mit Monad-Anwendung, label=Half2PS]
module Main where

import Prelude
import Data.Maybe

even x = mod x 2 == 0

decIfOdd :: Int -> Maybe Int
decIfOdd x = if even x
	then Just(x)
	else Just(x - 1)

half :: Int -> Maybe Int
half x = if even x
	then Just (div x 2)
	else Nothing

-- Ergebniskette: Just 20 - Just 10 - Just 5 - Just 4 - Just 2
ret = pure 20 >>= half >>= half >>= decIfOdd >>= half 
\end{lstlisting}

Hiermit sei noch einmal der Unterschied zu Applicatives verdeutlicht, dass bei Monaden, in der Aneinanderreihung von Funktionen, entschieden werden kann, welche Berechnung auf der Grundlage des Ergebnisses der vorherigen Berechnung ausgefÃ¼hrt werden soll. Aufgrund dessen, dass ein Funktor einen Typ hat, mÃ¼ssen die Funktionen einer Aneinanderreihung alle vom gleichen Funktor, wie hier z.B. \emph{Maybe}, sein.

FÃ¼r den \emph{bind}-Funktionsalias bietet PureScript syntaktischen Zucker in Form der Do-Notation an. In Listing \ref{DoNotPS} ist der Ã¤quivalente Aufruf in Do-Notation zu dem des vorherigen Listings \ref{Half2PS} aufgefÃ¼hrt.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Funktionen mit Monad-Anwendung in Do-Notation, label=DoNotPS]
ret = do 
	zwanzig <- pure 20									-- Syntax pattern: 						
	zehn <- half zwanzig								-- x >>= f = do y <- x
	fuenf <- half zehn									--  					  f y
	vier <- decIfOdd fuenf
	half vier
\end{lstlisting}

FÃ¼r Monaden gelten drei Gesetze, welche sich unmittelbar auf mÃ¶gliche Formulierungen in der Do-Notation auswirken und damit recht deutlich veranschaulicht werden kÃ¶nnen:
\begin{itemize}
  	\item Right Identiy: \lstinline[language=purescript, columns=fixed]{x >>= pure = x}
	\item Left Identiy: \lstinline[language=purescript, columns=fixed]{pure x >>= f = f x}
  	\item Associative Composition: \lstinline[language=purescript, columns=fixed]{(m >>= f) >>= g = m >>= (\x -> f x >>= g)}
\end{itemize}

Das Right-Identiy-Gesetz sagt aus, dass \emph{pure} weggelassen werden kann, wenn er der letzte Ausdruck ist \cite[][S. 102]{Freeman17}. Es macht also keinen Unterschied, ob man in Listing \ref{DoNotPS} den Ausdruck in Zeile 6 zuvor an eine weitere Konstante gebunden (z.B. \emph{zwei}) und dann in der nÃ¤chsten Zeile \emph{pure zwei} angefÃ¼gt hÃ¤tte.

\begin{wrapfigure}[12]{r}{.30\textwidth}
	\begin{lstlisting}[aboveskip=-1em, language=purescript, caption=Associative Composition, label=AssociativeCompositionPS]
		c1 = do 
			y <- do
				x <- m1
				m2 
			m3
			
		c2 = do 
			x <- m1
			y <- m2 
			m3
	\end{lstlisting}
\end{wrapfigure}

Das Left-Identity-Gesetz sagt aus, dass \emph{pure} weggelassen werden kann, wenn er der erste Ausdruck ist \cite[][S. 102--103]{Freeman17}. Es macht also keinen Unterschied, ob man in Listing \ref{DoNotPS} den Ausdruck in Zeile 2 nicht an die Konstante \emph{zwanzig} gebunden hÃ¤tte, sondern die \emph{20} anstelle der \emph{zwanzig} direkt in Zeile 3 hinter die Funktion \emph{half} schreiben wÃ¼rde.

Das Associative-Composition-Gesetzt sagt aus, dass wenn man eine Abfolge von monadischen Funktionsanwendungen hat, es keinen Unterschied macht, wie diese miteinander verschachtelt sind \cite[][S. 103]{Freeman17}. BezÃ¼glich der Do-Notation hat das die Auswirkung, dass \emph{c1} und \emph{c2} aus Listing \ref{AssociativeCompositionPS} Ã¤quivalent sind.

\subsection{Ãœbersetzung nach JavaScript}
In diesem Unterabschnitt  wird die Ãœbersetzung des Codebeispiels mit der \emph{Maybe}-Monade des vorangegangenen Unterabschnitts dargestellt und erlÃ¤utert.

Da es sich bei Monaden um eine Typklasse handelt, ist das Ãœbersetzungsmuster gemÃ¤ÃŸ des in Abschnitt \glqq \ref{lbl:Typeclasses} \nameref{lbl:Typeclasses}\grqq{} beschriebenen. Es wird also analog die Typklasse \emph{Monad} aus PureScript als Object Type (Klasse) in JavaScript reprÃ¤sentiert. Die Typinstanz fÃ¼r den ADT \emph{Maybe} ist ein Objekt (Type Class Dictionary) mit der Bezeichnung \emph{monadMaybe}.  Da in der Ãœbersetzung auf die Wertkonstruktoren \emph{Just a} und \emph{Nothing} des ADT \emph{Maybe} und auf die von Funktoren zurÃ¼ckgegriffen wird, lohnt ein Blick in Listing \ref{ADTMaybeFunctorJS}. Monaden stehen in der Typklassenhierarchie unter \emph{Applicative} und \emph{Bind}. Diese Beziehung wird Ã¼ber die Ãœbersetzung ebenfalls deutlich. Zur Reduzierung der LÃ¤nge der nachfolgenden Listings sind an geeigneten Stellen ZeilenumbrÃ¼che entfernt worden.

In Listing \ref{TypeClassMonadJS} ist die Ãœbersetzung der Typklassen \emph{Bind} und \emph{Monad} aus Listing \ref{MonadTCPS} nach JavaScript dargestellt. In \emph{Bind} wird dazu auf die Ãœbersetzung der Typklasse \emph{Apply} zurÃ¼ckgegriffen und in \emph{Monad} auf die von \emph{Applicative} und  \emph{Bind}. An dieser Stelle wird also die Beziehung zwischen diesen Typklassen deutlich und auch, dass eine Monade auch immer ein Applicative und damit ebenfalls ein Funktor ist, da sie Ã¼ber die gleichen FÃ¤higkeiten verfÃ¼gt.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung der Typklassen \emph{Bind} und \emph{Monad}, label=TypeClassMonadJS]
// ../Control.Bind/index.js
var Bind = function (Apply0, bind) {
	this.Apply0 = Apply0;
	this.bind = bind;
};
var bind = function (dict) { return dict.bind; };

// ../Control.Monad/index.js
var Monad = function (Applicative0, Bind1) {
	this.Applicative0 = Applicative0;
	this.Bind1 = Bind1;
};
\end{lstlisting}

Listing \ref{ADTMaybeMonadJS} zeigt, die Ãœbersetzung der Typinstanzen fÃ¼r \emph{Bind} und \emph{Monad} im Falle des ADT's \emph{Maybe} aus Listing \ref{MaybeMonadPS}.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung der Typinstanzen fÃ¼r \emph{Maybe}, label=ADTMaybeMonadJS]
// ../Data.Maybe/index.js
var bindMaybe = new Control_Bind.Bind(
function () {
	return applyMaybe;
}, function (v) {  // v1 ist ein Objekt, v eine Funktion, die
	return function (v1) { // einen ausgepackten Wert erwartet
		if (v instanceof Just) {
			return v1(v.value0);
		};
		if (v instanceof Nothing) {
			return Nothing.value;
		};
		throw new Error("<pattern error message skipped by author>");
	};
});

var monadMaybe = new Control_Monad.Monad(
function () {
	return applicativeMaybe;
}, function () {
	return bindMaybe;
});
\end{lstlisting}

Das Vorgehen unterscheidet sich nicht wesentlich von dem, welches wir bei Funktoren und Applicatives vorgefunden haben. Wegen der Typklassenhierarchie wird auch hier wieder auf die Typinstanzen des Ã¼bergeordneten Typs zugegriffen. Die Funktion \emph{bind} nimmt ein JavaScript-Objekt als Funktor (\emph{v1}) und eine Funktion (\emph{v}) entgegen. Im Falle von \emph{Just} wird der Wert im Objekt ausgepackt der Funktion fÃ¼r eine Berechnung Ã¼bergeben und deren bereits eingepackte RÃ¼ckgabe anschlieÃŸend einfach direkt zurÃ¼ckgegeben. Im Fall von \emph{Nothing} passiert das gleiche wie bei Funktoren und Applicatives. Da es fÃ¼r einen anderen Fall kein definiertes Verhalten gibt, wird in einem solchen ein Fehler geworfen.

In Listing \ref{ADTMaybeMonad2JS} ist die Ãœbersetzung des Beispiels mit dem ADT \emph{Maybe} als Monade aus Listing \ref{Half2PS} nach JavaScript aufgefÃ¼hrt. Auf die Ãœbersetzung der genutzten Berechnungsfunktion sei an dieser Stelle verzichtet.
\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung von Monaden mit Maybe nach JS, label=ADTMaybeMonad2JS]
var ret =
	Control_Bind.bind(Data_Maybe.bindMaybe)
	(Control_Bind.bind(Data_Maybe.bindMaybe)
		(Control_Bind.bind(Data_Maybe.bindMaybe)
			(Control_Bind.bind(Data_Maybe.bindMaybe)
				(Control_Applicative.pure(Data_Maybe.applicativeMaybe)
	(20))(half))(half))(decIfOdd))(half);
\end{lstlisting}

Das Type Class Dictionary \emph{bindMaybe} wird der freien Funktion \emph{bind} des Moduls \emph{Control.Bind} als Argument Ã¼berreicht. Diese Funktion ruft anschlieÃŸend die Klassenfunktion \emph{bind} auf. Der Aufruf von \emph{pure} geschieht auf Ã¤quivalente Weise. Die Funktionen sind in umgekehrter Reihenfolge zu ihren Argumenten fÃ¼r die Funktionswendung verschachtelt. Soll heiÃŸen, der Wert 20 wird von der innersten Funktion \emph{pure} (Zeile 6) angenommen und darauf folgt das erste \emph{half} fÃ¼r die zweitinnerste Funktion (Zeile 5) usw.

Listing \ref{DoNotJS} zeigt die Ãœbersetzung des Beispiels mit dem ADT \emph{Maybe} als Monade aus Listing \ref{DoNotPS} in Do-Notation nach JavaScript.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung von Monaden mit Maybe nach JS in Do-Notation, label=DoNotJS]
var ret = Control_Bind.bind(Data_Maybe.bindMaybe)
(Control_Applicative.pure(Data_Maybe.applicativeMaybe)(20))
(function (v) {
	return Control_Bind.bind(Data_Maybe.bindMaybe)(half(v))
	(function (v1) {
		return Control_Bind.bind(Data_Maybe.bindMaybe)(half(v1))
		(function (v2) {
			return Control_Bind.bind(Data_Maybe.bindMaybe)(decIfOdd(v2))
			(function (v3) {
				return half(v3);
			});
		});
	});
});
\end{lstlisting}

Es ist zu erkennen, dass sich ein Ã¤hnliches Muster wie bei einfacher \emph{bind}-Anwendung ergibt. Die Abweichungen resultieren aus dem Aspekt, dass die Zwischenergebnisse der Aufrufe in der Do-Notation benannt sind, was Ã¼ber Funktionen mit einem Argument realisiert wird. Deshalb ist die Reihenfolge der verschachtelten Funktionen und Type Class Dictionaries wieder wie sie auch in PureScript angegeben war.

\section{Lessons Learned}

\begin{itemize}
	\item Funktoren erlauben es durch \emph{map}, eine Funktion auf einen Wert in einem Funktor anzuwenden. Ein Weitermachen ist nicht definiert.
	\item Applicatives erlauben es durch \emph{apply}, eine Funktion in einem Funktor auf einen Wert in einem Funktor anzuwenden. Ein \textbf{Weitermachen} ist definiert, aber dieses nimmt keinen Bezug auf das Ergebnis einer vorangegangen Berechnung.
	\item Monaden erlauben es durch \emph{bind}, eine Funktion entgegen zu nehmen, die einen kontextlosen Wert nimmt und einen Wert in einem Kontext (Funktor bzw. hier Monade) zurÃ¼ckliefert. Ein \textbf{Weitermachen} ist definiert und um zu entscheiden \textbf{wie} weitergemacht werden soll, kann das Ergebnis einer vorangegangenen Berechnung als Ausgangswert genutzt werden.
\end{itemize}


\chapter{IO - Hallo Welt}
PureScript unterscheidet zwischen nativen und nicht-nativen Seiteneffekten. Unter nativen Seiteneffekten werden solche verstanden, die aus JavaScript herrÃ¼hren. Beispielsweise zÃ¤hlt darunter die Ein- und Ausgabe Ã¼ber die Konsole, Generierung von Zufallszahlen, Exceptions oder auch DOM Manipulationen. Ein Beispiel fÃ¼r einen Nicht-nativen Seiteneffekt wÃ¤re die Nutzung des ADT's \emph{Maybe} \cite[][S. 107--108]{Freeman17}.	

Die Monade, welche mit nativen Seiteneffekte umgehen soll, nennt sich \emph{Eff} und ist im Modul \emph{Control.Monad.Eff} definiert. An dieser Stelle sei erwÃ¤hnt, dass wir in diesem Abschnitt nur an der OberflÃ¤che kratzen werden, um den nachfolgenden, in Listing \ref{HelloWorldPS} dargestellten, Code verstehen zu kÃ¶nnen. FÃ¼r Details sei auf die angegebene Literatur verwiesen.

\begin{lstlisting}[language=purescript, style=numbered-and-boxed, caption=Hello World Beispiel, label=HelloWorldPS]
module Main where

import Prelude (Unit, show, bind, (<>))
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Console (CONSOLE, log)
import Control.Monad.Eff.Random (RANDOM, random) 

main :: forall eff. Eff (console :: CONSOLE, random :: RANDOM | eff) Unit
main = do
	n <- random
	log ((show n) <> " - Hello world!")
\end{lstlisting}

Fangen wir bei der Typdeklaration der Main-Funktion an. Im Gegensatz zu Haskell, kann in PureScript sehr granular bestimmt werden, welche Seiteneffekte \emph{main} haben darf. Die Funktion wird die Konsole nutzen und zusÃ¤tzlich Zufallszahlen generieren \cite[][S. 108--109]{Freeman17}. Das Akronym \emph{eff} steht fÃ¼r \emph{Extensible Effects}. Die Typdeklaration beschreibt vor dem Pipe-Zeichen, welche Berechnungen mit Seiteneffekten auftreten dÃ¼rfen. Solange diese unterstÃ¼tzt werden, kÃ¶nnen jedoch auch noch anderweitige Seiteneffekte auftreten. Die Typdeklaration liest sich in diesem konkreten Fall wie folgt: \glqq Die Funktion \emph{main} ist eine Berechnung mit Seiteneffekten, die in einem Berechnungskontext ausgefÃ¼hrt werden, welcher Ein- und Ausgabeoperationen auf der Konsole und die Generierung von Zufallszahlen unterstÃ¼tzt, und jede andere Art von Seiteneffekten, und wo ein Wert vom Typ \emph{Unit} zurÃ¼ckgegeben wird.\grqq{} \cite[][S. 109--110]{Freeman17}. Ohne darauf nÃ¤her eingehen zu wollen - diese Technik, nennt sich in PureScript \emph{Row Polymorphism} und steht in engem Bezug zu PureScript's Kind-System. So wie Werte nach Typen klassifiziert werden kÃ¶nnen, kÃ¶nnen Typen nach ihrer Art (kind) klassifiziert werden \cite[][S. 110--112]{Freeman17}.

Man kann den Typ der Funktion auch ohne \emph{Row Polymorphism} ausdrÃ¼cken. Dies wird dann (eingedeutscht) geschlossene Zeile von Effekten genannt, da die Row-Variable \emph{eff} nicht genutzt wird. Die Typdeklaration sÃ¤he so aus:\newline \lstinline[language=purescript, columns=fixed]{main :: Eff (console :: CONSOLE, random :: RANDOM) Unit}.\newline Dies hat den Vorteil, dass nicht aus Versehen eine Subberechnung von einem Seiteneffekt eines anderen Typs auftreten kann und den Nachteil, dass wir immer alle Seiteneffekte ins Detail festlegen mÃ¼ssen \cite[][S. 112]{Freeman17}. 

Die Monade \emph{Eff} ist im Grunde aufgebaut wie wir es bereits bei \emph{Maybe} im vorangegangen Kapitel Ã¼ber Funktoren, Applicatives und Monaden gesehen haben. Sie stellt allerdings mehr eine typsichere API fÃ¼r Berechnungen mit Seiteneffekten dar, da es das Ziel ist effizienten JavaScript Code zu generieren. Die GeschÃ¤ftslogik der Funktionen wird fast ausschlieÃŸlich Ã¼ber Foreign Function Imports realisiert und ist damit in JavaScript geschrieben \cite[][S. 109]{Freeman17}.

In Listing \ref{HelloWorldJS} ist, unter Verzicht auf manche Imports, die Ãœbersetzung des Hallo-Welt-Beispiels nach JavaScript dargestellt.

\begin{lstlisting}[language=javascript, style=numbered-and-boxed, caption=Ãœbersetzung Hello World Beispiel, label=HelloWorldJS]
var Control_Monad_Eff_Console = require("../Control.Monad.Eff.Console");
var Control_Monad_Eff_Random = require("../Control.Monad.Eff.Random");
var Data_Show = require("../Data.Show");

var main = function __do() {
	var v = Control_Monad_Eff_Random.random();
	return Control_Monad_Eff_Console.log(
		Data_Show.show(Data_Show.showNumber)(v) + " - Hello world!")();
};
\end{lstlisting}

FÃ¼r die Generierung von Zufallszahlen zwischen 0 und 1 in Zeile 6 kommt folgender JavaScript Code zum Einsatz: \lstinline[language=javascript, columns=fixed]{exports.random = Math.random;}. Um aus dieser Zufallszahl (\emph{v}) eine Zeichenkette zu machen, wird die Funktion \emph{showNumber} der Typklasse \emph{Show} genutzt. Diese Funktion ist ebenfalls in JavaScript implementiert und ruft, ein paar Details auÃŸer Acht gelassen, im Endeffekt JavaScript's \emph{toString()}-Methode auf. Im nachfolgendem Listing wird der ADT der Console und die Implementierung der Funktion \emph{log} aufgezeigt. Der \glqq Konsolen-Effekt\grqq{} reprÃ¤sentiert Berechnungen, die die Konsole nutzen und \emph{Effect} ist ein \emph{Kind}, kein Typ. Die Log-Funktion zum Schreiben einer Zeichenkette auf die Konsole ist auf offensichtliche Weise in JavaScript implementiert.

\noindent\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=purescript, style=only-rect, caption= Foreign Function PS, label=ConsolePS]
foreign import data CONSOLE :: Effect

foreign import log :: forall eff. String -> Eff 
	(console :: CONSOLE | eff) Unit
	\end{lstlisting}
\end{minipage}% 
% 
\hfill% 
\begin{minipage}[t]{.49\textwidth} 
	\hspace*{0pt}\begin{lstlisting}[language=javascript, style=only-rect, caption= Foreign Function JS, label=ConsoleJS] 
exports.log = function (s) {
	return function () {
		console.log(s);
		return {};
	};
};
	\end{lstlisting}
\end{minipage}
\hfill% 


\chapter{Reflexion}
Anhand dieser Ausarbeitung zeigt sich deutlich, dass funktionale Konzepte wie Typklassen, Funktionen hÃ¶herer Ordnung oder auch Funktoren auf Konzepte der Objektorientierten-Welt in einer intuitiven Art und Weise abgebildet werden kÃ¶nnen. Die Typsicherheit ist im Zielcode in JavaScript natÃ¼rlich nicht mehr gegeben. Viele der funktionalen Sprachbestandteile gehen Hand in Hand, was in ihrem mathematischen Fundament begrÃ¼ndet sein kÃ¶nnte. Beispielsweise stellten sich Typklassen und Algebraische Datentypen durch die Analyse als ein fundamentales Konstrukt in PureScript heraus - das Schmierwerk im Getriebe in funktionalen Sprachen. 

Es zeigte sich allerdings auch, dass um Sprachen wie PureScript zu verstehen, die HÃ¼rde, welche anfangs zu nehmen ist, um einiges hÃ¶her liegt als sie es bei einem OOP-Pendant wie Java oder JavaScript ist. Es mÃ¼ssen bspw. mindestens die in dieser Ausarbeitung vorgestellten Konzepte verstanden sein, um das Hallo Welt Beispiel des letzten Kapitels annÃ¤hernd erfassen zu kÃ¶nnen. Dies liegt zugegebenermaÃŸen an der Philosophie wie man mit Seiteneffekten umgehen mÃ¶chte, um durch eine selbst auferlegte  BeschrÃ¤nkung letztendlich einen Mehrwert generieren zu kÃ¶nnen. Deshalb erscheint das typische Hallo Welt Beispiel mit IO-Interaktionen als denkbar ungeeignet, um als Einsteigerbeispiel in einer funktionalen Sprache benutzt zu werden. Man kommt von IO aufgrund der Seiteneffekte unweigerlich zu Monaden, wofÃ¼r man mindestens Funktoren verstanden haben sollte und darÃ¼ber zu Algebraischen Datentypen und Typklassen.

Durch das Aufzeigen, was sich hinter zunÃ¤chst kompliziert erscheinenden Sprachbestandteilen aus PureScript verbirgt, konnte die Sprache in meinen Augen wesentlich besser erschlossen werden, als wenn man sie nur konzeptionell betrachtet hÃ¤tte. Der objektorientierte Zielcode ist verstÃ¤ndlich und besteht in seinem Kern auch aus recht einfachen Konstrukten. Etwas visuell undurchsichtig wird es meist nur aufgrund des Curryings von Funktionen und der damit verbundenen Verschachtlung.



\addcontentsline{toc}{chapter}{Abbildungsverzeichnis}
\listoffigures
\addcontentsline{toc}{chapter}{Listings}
\lstlistoflistings 

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------
\addcontentsline{toc}{chapter}{Literaturverzeichnis}
\printbibliography[title=Literaturverzeichnis]
%----------------------------------------------------------------------------------------

\end{document}